# NetTools 网络扫描工具箱开发手册

## 目录

1. [项目概述](#1-项目概述)
2. [环境搭建](#2-环境搭建)
3. [项目结构](#3-项目结构)
4. [核心模块](#4-核心模块)
5. [用户界面](#5-用户界面)
6. [配置管理](#6-配置管理)
7. [插件系统](#7-插件系统)
8. [工具与辅助模块](#8-工具与辅助模块)
9. [数据可视化](#9-数据可视化)
10. [开发指南](#10-开发指南)
11. [测试规范](#11-测试规范)
12. [常见问题与解决方案](#12-常见问题与解决方案)
13. [维护指南](#13-维护指南)

## 1. 项目概述

### 1.1 项目简介

NetTools 是一个功能强大的多模块网络扫描工具集合，提供命令行和图形界面两种操作方式。本工具设计用于网络安全分析、网络拓扑探测和漏洞扫描等任务，采用模块化设计架构，使得功能扩展和维护变得简单高效。

NetTools 主要面向网络管理员、安全工程师和网络开发人员，可以帮助他们快速获取网络信息、检测安全隐患和分析网络结构。

### 1.2 主要功能

- **主机扫描**：发现局域网或指定IP范围内的活跃主机
  - 支持ARP、ICMP、TCP多种探测方式
  - 自动识别主机MAC地址和操作系统类型
  - 生成网络拓扑图，直观显示主机间的连接关系
  - 支持网关自动识别与标记
  - 提供厂商MAC地址匹配功能，便于设备分类
  - 支持多线程并行扫描，显著提高大规模网络扫描效率
  - 实时显示扫描进度和发现的主机

- **端口扫描**：检测主机开放端口和运行的服务
  - 支持TCP SYN、TCP Connect、UDP多种扫描方式
  - 自动识别常见服务和版本信息
  - 可配置扫描速度和超时参数
  - 内置服务指纹库，可识别1000+种常见服务
  - 提供端口分组功能，可按服务类型（Web、数据库、远程管理等）分类显示
  - 支持自定义端口范围或使用预设的端口组（如"常用"、"全部"、"危险"等）
  - 实现智能扫描节奏控制，避免触发目标防火墙或IDS

- **DNS检测**：域名解析和记录查询
  - 查询A、AAAA、MX、NS、CNAME等各类DNS记录
  - 支持反向解析（PTR记录）查询
  - 子域名枚举功能
  - DNS服务器配置检测
  - 递归与迭代查询支持
  - DNS区域传送漏洞检测
  - 支持DNSSEC验证
  - 提供DNS响应时间分析
  - 多DNS服务器对比功能

- **路由追踪**：网络路径分析
  - 可视化显示数据包经过的路由节点
  - 支持ICMPv4、ICMPv6、UDP和TCP多种追踪方式
  - 提供每一跳的延迟统计
  - 自动进行路由器主机名解析
  - 显示AS号和ISP信息
  - 地理位置标记功能（国家/地区/城市）
  - 路径拓扑图可视化
  - 路径变化监控与对比

- **Ping监控**：网络连通性检测
  - 长期监控目标主机状态
  - 提供图形化的延迟统计和丢包率
  - 支持告警功能
  - 可自定义监控间隔和告警阈值
  - 支持多目标并行监控
  - 提供最小/平均/最大延迟和抖动分析
  - 历史数据记录与趋势分析
  - 支持导出监控报告

- **TCP Ping**：基于TCP的连通性测试
  - 适用于ICMP被防火墙阻止的环境
  - 可自定义目标端口
  - 提供与标准ICMP Ping对比功能
  - 支持IPv4和IPv6
  - TCP握手时间精确测量
  - 适用于Web服务可用性监控

- **Web目录扫描**：Web应用目录探测
  - 内置常见目录和文件字典
  - 支持自定义字典和排除规则
  - 自动识别重定向和错误页面
  - 支持HTTP基本认证和表单认证
  - 自动处理Cookies和会话
  - 支持不同的HTTP请求方法（GET、HEAD、POST）
  - 智能调节扫描速率，避免目标服务器过载
  - 可发现敏感文件和目录（如备份文件、配置文件、管理界面）

- **Web风险扫描**：Web应用安全检测
  - Web服务指纹识别
    - 识别Web服务器类型和版本
    - 检测使用的Web框架和CMS系统
    - 识别JavaScript库和插件版本
  - 常见安全漏洞检测
    - SQL注入漏洞检测
    - 跨站脚本攻击(XSS)检测
    - 跨站请求伪造(CSRF)检测
    - 文件包含漏洞检测
    - 命令注入漏洞检测
  - 安全响应头分析
    - 检查Content-Security-Policy配置
    - 验证X-XSS-Protection设置
    - 分析HSTS和Cookie安全属性
  - WAF(Web应用防火墙)检测
    - 识别常见WAF产品
    - 提供绕过建议
  - 敏感信息泄露检测
    - 检测源代码、配置文件暴露
    - API密钥和凭证泄露检测
  - SSL/TLS安全配置分析
    - 检测弱加密算法和协议版本
    - 证书有效性验证

- **POC扫描**：漏洞验证与利用
  - 支持CVE编号直接查询与验证
  - 内置常见漏洞的验证脚本
  - 提供可定制的漏洞验证框架
  - 安全无损的验证方式
  - 支持批量验证和定期自动验证
  - 与国家漏洞库(CNNVD/CNVD)和国际漏洞库(NVD)集成

- **暴力破解**：密码强度测试
  - 支持多种协议（FTP、SSH、Telnet、SMTP等）
  - 内置常见默认密码库
  - 字典攻击与规则生成功能
  - 防止账户锁定的智能控制措施
  - 多线程参数可调
  - 支持自定义用户名和密码列表
  - 提供破解结果的安全报告

### 1.3 技术特点

- **模块化设计**：每个功能模块独立封装，便于维护和扩展
  - 核心扫描逻辑与UI界面分离
  - 基于接口和抽象类的扩展机制
  - 一致的模块通信协议
  - 松耦合架构，单个模块可独立升级和替换
  - 标准化的数据结构和接口定义
- **双重界面**：CLI和GUI两种操作方式
  - 命令行工具支持脚本自动化
  - 图形界面提供直观的操作和结果展示
  - 两种界面共享核心业务逻辑
  - 支持命令行参数批处理执行
  - GUI提供实时进度展示和交互式操作
- **多线程并发**：高效的资源利用
  - 扫描任务并行执行提高效率
  - 自适应线程池管理，根据系统资源动态调整
  - 任务优先级队列，确保关键任务优先执行
  - 线程安全的数据结构，确保结果一致性
  - 可配置的并发度，适应不同硬件环境
- **智能扫描策略**：平衡性能与准确性
  - 自适应扫描速率，避免触发防御机制
  - 智能重试机制，处理网络波动和暂时性故障
  - 渐进式扫描策略，先进行快速检测再深入分析
  - 目标优先级排序，基于之前的扫描结果
  - 资源敏感调度，避免目标系统过载
- **数据导出**：支持多种格式
  - CSV格式：便于电子表格软件处理
  - JSON格式：便于程序化处理
  - Excel格式：提供丰富的数据表现形式
  - HTML报告：生成可视化安全评估报告
  - XML格式：支持与其他安全工具集成
  - 自定义模板：可定制报告样式和内容
- **配置管理**：灵活的配置系统
  - 全局配置：适用于所有模块的通用设置
  - 模块配置：针对特定模块的专用设置
  - 用户配置：保存用户偏好
  - 配置文件版本管理，支持向后兼容
  - 配置项校验机制，防止无效配置
  - 动态配置热加载，无需重启应用
- **插件扩展**：丰富的扩展能力
  - 插件API：统一的插件接口
  - 动态加载：运行时发现和加载插件
  - 配置驱动：通过配置文件控制插件行为
  - 插件依赖管理，自动解析和加载依赖插件
  - 插件隔离机制，确保核心功能不受影响
  - 插件生命周期管理，支持热插拔
- **可视化**：直观的数据展示
  - NetworkX网络拓扑图：展示网络结构
  - 实时图表：展示性能和统计数据
  - 交互式操作：支持缩放、拖拽等交互
  - 热力图：直观显示网络活跃度分布
  - 时间轴视图：展示网络变化趋势
  - 3D拓扑：支持复杂网络结构可视化
- **安全设计**：保障工具本身和目标系统安全
  - 扫描权限控制，避免非授权使用
  - 敏感数据加密存储，保护扫描结果
  - 无损扫描原则，避免影响目标系统
  - 扫描行为日志，便于审计和追溯
  - 内置限流机制，防止资源滥用
  - 支持安全认证和HTTPS连接
- **跨平台兼容**：一次开发，多平台运行
  - 支持Windows、Linux、macOS三大主流操作系统
  - 自动适应不同操作系统的网络API差异
  - 兼容性检测，识别平台特定功能限制
  - 统一的资源访问接口，屏蔽平台差异
  - 构建脚本支持跨平台打包和分发

### 1.4 应用场景

- **网络资产管理**：快速发现和统计网络中的设备和服务
- **安全评估**：检测网络和Web应用中的安全隐患
- **网络排障**：分析网络连通性和路由问题
- **性能监控**：监控关键设备的网络性能指标
- **安全研究**：为安全研究人员提供丰富的网络工具集

## 2. 环境搭建

### 2.1 系统要求

- **Python环境**：
  - Python 3.8 或更高版本
  - pip 20.0 或更高版本
  
- **操作系统支持**：
  - Windows 10/11 x64
  - Ubuntu 20.04/22.04 LTS
  - macOS 11.0+（Big Sur及更高版本）
  
- **硬件建议**：
  - CPU：2核心或以上
  - 内存：4GB或以上（大规模扫描建议8GB以上）
  - 磁盘空间：500MB可用空间
  
- **网络权限**：
  - 部分功能（如ARP扫描、原始套接字操作）需要管理员/root权限
  - 防火墙配置可能需要调整

### 2.2 依赖包

项目核心依赖包及其用途：

```
# 网络功能
scapy>=2.4.5       # 网络数据包处理和构造
netifaces>=0.11.0  # 网络接口信息获取
ipaddress>=1.0.23  # IP地址和网络操作
dnspython>=2.1.0   # DNS查询和解析
ping3>=2.9.0       # 纯Python的ping实现
socket-timeout-decorator>=0.2.0  # 为套接字操作添加超时控制

# HTTP和Web
requests>=2.28.0   # HTTP请求
beautifulsoup4>=4.10.0  # HTML解析
aiohttp>=3.8.0     # 异步HTTP请求
urllib3>=1.26.9    # HTTP客户端
lxml>=4.6.3        # XML和HTML处理
selenium>=4.1.0    # Web自动化测试（用于复杂Web扫描）
webdriver-manager>=3.5.2  # WebDriver自动管理

# GUI
PyQt5>=5.15.0      # 图形界面框架
PyQtWebEngine>=5.15.2  # Qt Web引擎（用于显示HTML报告）
qt-material>=2.8.0  # 现代化Qt主题

# 数据处理
pandas>=1.3.0      # 数据分析和处理
openpyxl>=3.0.7    # Excel文件读写
sqlalchemy>=1.4.0  # 数据库ORM（用于结果存储）
pyarrow>=7.0.0     # 高性能数据存储格式

# 数据可视化
networkx>=2.8.0    # 网络图创建和分析
matplotlib>=3.5.0  # 数据绘图
seaborn>=0.11.2    # 统计数据可视化
plotly>=5.6.0      # 交互式图表
scipy>=1.10.0      # 科学计算（网络布局算法）

# 工具和辅助
pyyaml>=6.0        # YAML配置文件解析
cryptography>=36.0.0  # 加密功能
tqdm>=4.62.0       # 进度条显示
python-dateutil>=2.8.2  # 日期时间处理
humanize>=4.0.0    # 人性化数据显示（如文件大小、时间间隔）
colorama>=0.4.4    # 终端彩色输出
psutil>=5.9.0      # 系统资源监控
schedule>=1.1.0    # 任务调度
python-dotenv>=0.20.0  # 环境变量管理

# 安全相关
pyopenssl>=22.0.0  # OpenSSL封装
oauthlib>=3.2.0    # OAuth认证
bcrypt>=3.2.0      # 密码哈希
jwt>=1.3.1         # JSON Web Token
pyjwt>=2.3.0       # JWT实现
```

#### 依赖分组

**基础依赖**（必需）：
```
# 核心网络功能
scapy>=2.4.5        # 数据包处理
netifaces>=0.11.0   # 网络接口
requests>=2.28.0    # HTTP客户端
ipaddress>=1.0.23   # IP地址处理

# 基础UI
PyQt5>=5.15.0       # GUI框架
colorama>=0.4.4     # CLI着色

# 数据处理
pandas>=1.3.0       # 数据分析
pyyaml>=6.0         # 配置解析

# 可视化
networkx>=2.8.0     # 网络图
matplotlib>=3.5.0   # 绘图
```

**扩展依赖**（特定功能需要）：
```
# 数据导出
openpyxl>=3.0.7         # Excel导出
sqlalchemy>=1.4.0       # 数据库存储

# 高级可视化
seaborn>=0.11.2         # 统计图表
plotly>=5.6.0           # 交互式图表
scipy>=1.10.0           # 高级网络布局

# Web扫描
beautifulsoup4>=4.10.0  # HTML解析
selenium>=4.1.0         # 动态页面扫描
lxml>=4.6.3             # XML解析

# DNS功能
dnspython>=2.1.0        # DNS操作

# 高级UI
PyQtWebEngine>=5.15.2   # HTML报告查看
qt-material>=2.8.0      # 现代UI主题
```

**开发依赖**（仅开发环境需要）：
```
# 测试工具
pytest>=7.0.0         # 单元测试框架
pytest-cov>=3.0.0     # 代码覆盖率
pytest-mock>=3.7.0    # 测试模拟
pytest-benchmark>=3.4.1  # 性能测试

# 代码质量
pylint>=2.12.0        # 代码检查
black>=22.1.0         # 代码格式化
isort>=5.10.0         # 导入排序
mypy>=0.931           # 类型检查

# 文档
sphinx>=4.4.0         # 文档生成
sphinx-rtd-theme>=1.0.0  # 文档主题
sphinx-autodoc-typehints>=1.17.0  # 类型提示支持

# 打包和分发
setuptools>=60.0.0    # 包构建工具
wheel>=0.37.0         # 二进制分发
twine>=3.8.0          # PyPI上传
```

#### 依赖兼容性说明

1. **Python版本兼容性**：
   - 最低支持：Python 3.8
   - 建议使用：Python 3.9 或 3.10
   - 兼容性问题：部分第三方库在低版本Python上可能有兼容性问题

2. **平台特定依赖**：
   | 依赖项 | Windows | Linux | macOS | 备注 |
   |--------|---------|-------|-------|------|
   | scapy  | 需要Npcap | 需要libpcap | 需要libpcap | 不同平台需要不同的底层库 |
   | PyQt5  | 全支持  | 全支持 | 全支持 | 在macOS上可能需要额外配置 |
   | netifaces | 需预编译轮子 | 需编译工具 | 需编译工具 | Windows推荐使用预编译版本 |

3. **可选依赖项**：
   - `aiohttp`：仅在使用异步HTTP扫描时需要
   - `selenium`：仅在需要复杂Web内容分析时需要
   - `PyQtWebEngine`：仅需要在GUI中查看HTML报告时安装

#### 版本控制和依赖管理

项目使用以下方法管理依赖版本：

1. **版本固定**：核心依赖使用固定版本号，确保稳定性
2. **最低版本限制**：使用 `>=` 指定最低版本要求
3. **依赖分组**：通过多个 requirements 文件区分不同环境依赖：
   - `requirements.txt`：基本运行环境
   - `requirements-dev.txt`：开发环境
   - `requirements-test.txt`：测试环境
   - `requirements-docs.txt`：文档生成环境

4. **依赖更新策略**：
   - 安全更新：立即应用
   - 功能更新：按季度评估
   - 主版本更新：经过完整测试后应用

### 2.3 安装步骤

#### 2.3.1 基础安装

1. 克隆代码库：
```bash
git clone <repository_url>
cd nettools
```

2. 创建虚拟环境：
```bash
# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
## Linux/macOS:
source venv/bin/activate
## Windows:
venv\Scripts\activate
```

3. 安装依赖：
```bash
# 使用setup.py（推荐）
python setup.py

# 或直接安装所有依赖
pip install -r requirements.txt
```

#### 2.3.2 操作系统特定设置

**Windows系统**：
1. 安装Npcap（Scapy的依赖）：
   - 下载: https://npcap.com/
   - 安装时选择"Install Npcap in WinPcap API-compatible Mode"

2. 管理员权限：
   - 部分功能需要以管理员身份运行命令提示符或PowerShell

**Linux系统**：
1. 安装依赖包：
```bash
# Ubuntu/Debian:
sudo apt-get update
sudo apt-get install -y python3-dev libpcap-dev
```

2. 配置权限：
```bash
# 允许非root用户使用ping
sudo sysctl -w net.ipv4.ping_group_range="0 2147483647"

# 或将应用程序设置为setcap
sudo setcap cap_net_raw+ep $(which python3)
```

**macOS系统**：
1. 安装依赖：
```bash
# 通过Homebrew安装
brew install libpcap
```

2. 权限设置：
   - 部分功能需要在终端中使用sudo运行

#### 2.3.3 开发环境设置

对于开发者，建议安装以下额外工具：

```bash
# 开发工具
pip install -r requirements-dev.txt

# 包含以下内容：
# pytest - 单元测试
# pylint - 代码检查
# autopep8 - 代码格式化
# sphinx - 文档生成
```

### 2.4 运行方式

NetTools提供了多种灵活的运行方式，适应不同的使用场景和用户偏好。

#### 2.4.1 图形界面

启动图形用户界面（GUI）：
```bash
# 直接运行模块
python -m gui.main

# 或使用安装后的快捷命令（如果通过setup.py安装）
nettools-gui

# 指定配置文件启动
python -m gui.main --config /path/to/custom/settings.ini

# 以调试模式启动（显示更详细的日志）
python -m gui.main --debug

# 指定主题启动
python -m gui.main --theme dark
```

**GUI启动参数**：

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `--config` | 指定配置文件路径 | config/settings.ini |
| `--theme` | 界面主题 (light/dark/system) | system |
| `--lang` | 界面语言 (zh_CN/en_US) | 系统语言 |
| `--debug` | 启用调试模式 | 关闭 |
| `--maximize` | 启动时最大化窗口 | 关闭 |
| `--portable` | 便携模式（配置存储在程序目录） | 关闭 |

#### 2.4.2 命令行界面

使用命令行界面（CLI）：
```bash
# 显示帮助
python -m cli.main --help

# 列出可用模块
python -m cli.main list

# 运行特定扫描模块
python -m cli.main run <module_name> [options]

# 例如，扫描主机
python -m cli.main run hostscanner --ip_range 192.168.1.0/24

# 或使用安装后的快捷命令
nettools-cli run hostscanner --ip_range 192.168.1.0/24

# 静默模式运行（仅输出结果，无进度信息）
python -m cli.main run portscanner --target 192.168.1.1 --quiet

# 详细模式运行（显示详细调试信息）
python -m cli.main run dnscheck --domain example.com --verbose

# JSON输出格式
python -m cli.main run hostscanner --ip_range 192.168.1.0/24 --format json
```

**CLI全局参数**：

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `--config` | 指定配置文件路径 | config/settings.ini |
| `--output` | 输出文件路径 | 标准输出 |
| `--format` | 输出格式 (text/json/csv) | text |
| `--verbose`, `-v` | 详细输出 | 关闭 |
| `--quiet`, `-q` | 静默模式 | 关闭 |
| `--no-color` | 禁用彩色输出 | 关闭 |
| `--debug` | 调试模式 | 关闭 |

#### 2.4.3 配置管理

通过命令行管理配置：
```bash
# 查看当前配置
python -m cli.main config show

# 查看特定配置部分
python -m cli.main config show network

# 设置配置项
python -m cli.main config set scanning.max_threads 20

# 重置配置到默认值
python -m cli.main config reset

# 导出配置到文件
python -m cli.main config export custom_config.ini

# 从文件导入配置
python -m cli.main config import custom_config.ini

# 获取配置项说明
python -m cli.main config help scanning.max_threads
```

#### 2.4.4 Web界面（实验性）

NetTools提供了一个实验性的Web界面，可以通过浏览器远程访问：

```bash
# 启动Web服务器
python -m web.server

# 指定端口
python -m web.server --port 8080

# 指定绑定地址（仅本地访问）
python -m web.server --host 127.0.0.1

# 启用身份验证
python -m web.server --auth
```

访问方式：打开浏览器，访问 `http://localhost:5000`（或指定的端口）

#### 2.4.5 API模式

作为第三方库使用NetTools的API：

```python
# 导入相关模块
from core.scanner_manager import ScannerManager
from utils.config import ConfigManager

# 初始化配置管理器
config_manager = ConfigManager()

# 初始化扫描器管理器
scanner_manager = ScannerManager()

# 创建并配置扫描器
host_scanner = scanner_manager.create_scanner("HostScanner", {
    "ip_range": "192.168.1.0/24",
    "method": "icmp",
    "timeout": 2
})

# 执行扫描
result = host_scanner.execute()

# 处理结果
if result.success:
    print(f"Found {result.record_count} hosts:")
    for host in result.data:
        print(f"- {host['ip']} ({host.get('hostname', 'Unknown')})")
else:
    print(f"Scan failed: {result.error_msg}")
```

#### 2.4.6 守护进程模式

在服务器环境下以守护进程方式运行：

```bash
# 启动守护进程
python -m daemon.manager start

# 停止守护进程
python -m daemon.manager stop

# 查看状态
python -m daemon.manager status

# 重新加载配置
python -m daemon.manager reload
```

**守护进程配置文件**: `config/daemon.ini`

#### 2.4.7 Docker容器

使用Docker容器运行NetTools：

```bash
# 构建镜像
docker build -t nettools .

# 运行CLI模式
docker run -it --network host nettools cli run hostscanner --ip_range 192.168.1.0/24

# 运行Web界面
docker run -d -p 5000:5000 nettools web
```

#### 2.4.8 跨平台执行说明

| 功能 | Windows | Linux | macOS | 注意事项 |
|------|---------|-------|-------|---------|
| GUI界面 | ✓ | ✓ | ✓ | macOS可能需要XQuartz |
| CLI界面 | ✓ | ✓ | ✓ | 全平台通用 |
| 特权操作 | 管理员模式 | sudo或root | sudo | 部分扫描需要特权 |
| 后台服务 | 服务模式 | systemd或supervisor | launchd | 平台相关的服务注册方式不同 |
| Docker | 需WSL2或Docker Desktop | 原生支持 | 需Docker Desktop | 网络模式可能因平台而异 |

#### 2.4.9 性能和资源注意事项

- **内存使用**：大规模扫描可能需要较多内存，可通过`--max-memory`参数限制
- **CPU使用**：可通过`--max-threads`和`--process-limit`控制资源使用
- **网络带宽**：高速扫描可能占用大量带宽，可通过`--rate-limit`参数控制
- **存储空间**：结果文件可能占用大量空间，定期清理`results/`目录

### 2.5 快速入门示例

#### 主机扫描示例

```bash
# CLI方式
python -m cli.main run hostscanner --ip_range 192.168.1.0/24 --method icmp

# 导出结果到CSV
python -m cli.main run hostscanner --ip_range 192.168.1.0/24 --output results/hosts.csv
```

#### 端口扫描示例

```bash
# 扫描单个主机的常用端口
python -m cli.main run portscanner --target 192.168.1.1 --ports common

# 扫描特定端口范围
python -m cli.main run portscanner --target 192.168.1.1 --ports 1-1000 --method syn
```

#### Web风险扫描示例

```bash
# 扫描网站安全性
python -m cli.main run webriskscanner --url https://example.com --check-headers --check-waf
```

## 3. 项目结构

### 3.1 项目架构设计

NetTools采用分层架构设计，将系统划分为多个层次，每个层次负责特定的功能，实现关注点分离。

#### 3.1.1 整体架构

项目采用经典的三层架构，同时结合插件化设计：

```
+------------------------------------------+
|                  表现层                   |
|  +---------------+  +------------------+ |
|  |  图形界面(GUI)  |  |  命令行界面(CLI)  | |
|  +---------------+  +------------------+ |
+------------------------------------------+
|                  业务层                   |
|  +---------------+  +------------------+ |
|  |  核心扫描模块   |  |     插件系统     | |
|  +---------------+  +------------------+ |
+------------------------------------------+
|                  基础层                   |
|  +---------------+  +------------------+ |
|  |  工具和辅助类   |  |   配置和数据管理  | |
|  +---------------+  +------------------+ |
+------------------------------------------+
```

- **表现层**：负责与用户交互，包括GUI和CLI两种界面
- **业务层**：实现核心功能逻辑，包括各种扫描器和插件
- **基础层**：提供通用工具和辅助功能，支持上层模块

#### 3.1.2 设计模式应用

项目实现过程中应用了多种设计模式，确保代码的可扩展性和可维护性：

1. **工厂模式**：`ScannerManager`类使用工厂模式创建扫描器实例
2. **策略模式**：不同的扫描方法（如ARP/ICMP/TCP）作为可互换的策略
3. **观察者模式**：进度更新和事件通知采用观察者模式（回调函数）
4. **单例模式**：配置管理器和日志管理器使用单例模式
5. **装饰器模式**：用于扩展扫描器功能，如添加缓存、日志记录等
6. **适配器模式**：适配不同平台的网络API差异
7. **复合模式**：GUI中的面板和组件构成了复合模式结构
8. **模板方法模式**：`BaseScanner.execute()`定义扫描流程框架，子类实现特定步骤

#### 3.1.3 模块化设计原则

NetTools遵循以下模块化设计原则：

- **高内聚、低耦合**：每个模块专注于单一功能，最小化模块间依赖
- **接口分离**：定义清晰的接口约束，隐藏实现细节
- **依赖倒置**：核心模块依赖抽象接口，不依赖具体实现
- **开闭原则**：扩展功能主要通过继承和插件实现，不修改现有代码
- **显式胜于隐式**：接口和功能设计清晰明确，避免"魔法"实现

### 3.2 目录结构总览

NetTools项目采用模块化设计，各个功能组件按照职责划分到不同目录中：

```
nettools/
├── cli/                    # 命令行界面
│   ├── main.py             # CLI入口
│   ├── commands/           # 子命令实现
│   │   ├── run.py          # 扫描运行命令
│   │   ├── list.py         # 列出模块命令
│   │   └── config.py       # 配置管理命令
│   ├── config/             # CLI配置
│   ├── logs/               # CLI日志
│   └── __init__.py
│
├── config/                 # 主配置目录
│   ├── settings.ini        # 全局配置文件
│   ├── logging.ini         # 日志配置
│   └── defaults/           # 默认配置模板
│
├── configs/                # 扩展配置目录
│   ├── plugins/            # 插件配置文件
│   │   ├── fingerprintscanner.json  # Web指纹识别配置
│   │   ├── sqlinjectionscanner.json # SQL注入扫描配置
│   │   ├── wafdetector.json         # WAF检测配置
│   │   └── ...
│   ├── scanners/           # 扫描器配置文件
│   │   ├── hostscan.json   # 主机扫描配置
│   │   └── portscan.json   # 端口扫描配置
│   ├── dictionaries/       # 扫描字典目录
│   │   ├── webdirs.txt     # Web目录字典
│   │   ├── passwords.txt   # 默认密码字典
│   │   └── subdomains.txt  # 子域名字典
│   └── fingerprints.txt    # Web指纹库
│
├── core/                   # 核心扫描逻辑
│   ├── base_scanner.py     # 扫描器基类
│   ├── scanner_manager.py  # 扫描器管理器
│   ├── host_scan.py        # 主机扫描实现
│   ├── port_scan.py        # 端口扫描实现
│   ├── dns_check.py        # DNS检测实现
│   ├── traceroute.py       # 路由追踪实现
│   ├── ping_monitor.py     # Ping监控实现
│   ├── tcp_ping.py         # TCP Ping实现
│   ├── web_dir_scan.py     # Web目录扫描实现
│   ├── web_risk_scan.py    # Web风险扫描实现
│   └── __init__.py
│
├── gui/                    # 图形界面
│   ├── main.py             # GUI入口
│   ├── config_editor.py    # 配置编辑器
│   ├── plugin_config_editor.py  # 插件配置编辑器
│   ├── host_topology_networkx.py  # 主机拓扑图
│   ├── port_topology_networkx.py  # 端口拓扑图
│   ├── resources/          # GUI资源文件
│   │   ├── icons/          # 图标文件
│   │   ├── stylesheets/    # 样式表
│   │   └── translations/   # 国际化翻译文件
│   ├── widgets/            # 自定义控件
│   │   ├── custom_table.py # 自定义表格
│   │   └── progress_dialog.py # 进度对话框
│   ├── panels/             # 功能面板
│   │   ├── base_panel.py   # 面板基类
│   │   ├── host_scan_panel.py  # 主机扫描面板
│   │   ├── port_scan_panel.py  # 端口扫描面板
│   │   ├── dns_panel.py        # DNS检测面板
│   │   ├── traceroute_panel.py # 路由追踪面板
│   │   ├── ping_monitor_panel.py  # Ping监控面板
│   │   ├── tcp_ping_panel.py      # TCP Ping面板
│   │   ├── web_dir_scan_panel.py  # Web目录扫描面板
│   │   └── web_risk_scan_panel.py # Web风险扫描面板
│   └── __init__.py
│
├── logs/                   # 日志文件目录
│   ├── nettools.log        # 主程序日志
│   ├── scanner.log         # 扫描器日志
│   ├── gui.log             # GUI日志
│   └── cli.log             # CLI日志
│
├── plugins/                # 插件系统
│   ├── base_plugin.py      # 插件基类
│   ├── plugin_manager.py   # 插件管理器
│   ├── config_manager.py   # 插件配置管理
│   ├── web_risk/           # Web风险扫描插件
│   │   ├── fingerprint.py  # Web指纹识别插件
│   │   ├── waf_detector.py # WAF检测插件
│   │   ├── header_check.py # HTTP头检查插件
│   │   └── xss_scanner.py  # XSS漏洞扫描插件
│   ├── post_processing/    # 后处理插件
│   │   ├── report_generator.py  # 报告生成插件
│   │   └── visualization.py     # 数据可视化插件
│   └── __init__.py
│
├── results/                # 扫描结果存储目录
│   ├── reports/            # 生成的报告
│   ├── exports/            # 导出的数据文件
│   └── cache/              # 缓存数据
│
├── tests/                  # 测试代码
│   ├── unit/               # 单元测试
│   │   ├── core/           # 核心模块测试
│   │   ├── utils/          # 工具模块测试
│   │   └── plugins/        # 插件测试
│   ├── integration/        # 集成测试
│   ├── fixtures/           # 测试数据和夹具
│   └── __init__.py
│
├── utils/                  # 工具函数
│   ├── network.py          # 网络工具
│   ├── config.py           # 配置工具
│   ├── export.py           # 数据导出工具
│   ├── logger.py           # 日志工具
│   ├── validators.py       # 数据验证工具
│   ├── security.py         # 安全相关工具
│   ├── system.py           # 系统信息工具
│   └── __init__.py
│
├── web/                    # Web界面模块
│   ├── server.py           # Web服务器
│   ├── api/                # API实现
│   ├── templates/          # HTML模板
│   ├── static/             # 静态资源
│   └── __init__.py
│
├── daemon/                 # 守护进程模块
│   ├── manager.py          # 守护进程管理器
│   ├── service.py          # 服务实现
│   └── __init__.py
│
├── docs/                   # 文档目录
│   ├── api/                # API文档
│   ├── user_guide/         # 用户指南
│   └── dev_guide/          # 开发指南
│
├── README.md               # 项目说明
├── CONTRIBUTING.md         # 贡献指南
├── CHANGELOG.md            # 变更日志
├── LICENSE                 # 许可证文件
├── requirements.txt        # 依赖清单
├── requirements-dev.txt    # 开发依赖
├── setup.py                # 安装脚本
├── setup.cfg               # 安装配置
├── pyproject.toml          # 项目元数据
├── .gitignore              # Git忽略文件
├── .dockerignore           # Docker忽略文件
├── Dockerfile              # Docker构建文件
└── docker-compose.yml      # Docker Compose配置
```

### 3.3 核心目录说明

#### 3.3.1 `core/` 目录

包含所有扫描功能的核心实现，是项目的业务逻辑层：

- `base_scanner.py`: 定义了`BaseScanner`抽象基类和`ScanResult`数据类，所有扫描器的基础
- `scanner_manager.py`: 管理和调度各种扫描器的工厂类
- 各种扫描器实现文件：每个文件对应一种扫描功能，继承自`BaseScanner`

**文件结构示例**：`core/base_scanner.py`

```python
# core/base_scanner.py 的核心内容
class BaseScanner(abc.ABC):
    """所有扫描器的基类"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.task_id = str(uuid.uuid4())
        self.running = False
        
    @abc.abstractmethod
    def validate_config(self) -> Tuple[bool, Optional[str]]:
        """验证配置参数"""
        pass
        
    @abc.abstractmethod
    def run_scan(self) -> ScanResult:
        """执行扫描"""
        pass
```

**UML类图**：核心扫描模块继承关系

```
         +--------------+
         | BaseScanner  |
         +--------------+
         | +validate()  |
         | +run_scan()  |
         | +execute()   |
         +--------------+
                ^
                |
     +----------+----------+
     |          |          |
+----------+ +--------+ +---------+
| HostScan | |PortScan| |DNSCheck |...
+----------+ +--------+ +---------+
```

#### 3.3.2 `gui/` 目录

包含图形用户界面的实现：

- `main.py`: 应用程序主窗口，包含菜单、状态栏和Tab容器
- `panels/`: 每个扫描功能对应的UI面板，封装用户交互和结果展示
- `*_topology_networkx.py`: 网络拓扑图的可视化实现
- `config_editor.py`和`plugin_config_editor.py`: 配置编辑器

**面板结构**：每个功能面板继承自BasePanel，实现特定功能的UI

```
         +-------------+
         |  BasePanel  |
         +-------------+
         | +start_scan()|
         | +stop_scan() |
         | +display()   |
         +-------------+
                ^
                |
     +----------+----------+
     |          |          |
+-------------+ +------------+ +------------+
|HostScanPanel| |PortScanPanel| |DNSCheckPanel|...
+-------------+ +------------+ +------------+
```

#### 3.3.3 `cli/` 目录

命令行界面的实现：

- `main.py`: 命令行程序入口，解析参数并调用相应功能
- `commands/`: 子命令实现目录，包含各种命令处理器
- 支持子命令如`run`、`list`、`config`等

**命令解析流程**：

```
命令行参数 -> 参数解析 -> 命令分发 -> 特定命令处理器 -> 执行扫描/配置操作
```

#### 3.3.4 `plugins/` 目录

插件系统的核心实现：

- `base_plugin.py`: 定义插件接口
- `plugin_manager.py`: 插件的发现、加载和管理
- `config_manager.py`: 插件配置的读写
- 各种插件实现子目录，如`web_risk/`

**插件发现和加载流程**：

```
配置读取 -> 插件目录扫描 -> 加载插件类 -> 验证插件接口 -> 注册到插件管理器 -> 按需实例化
```

#### 3.3.5 `utils/` 目录

通用工具和辅助函数：

- `network.py`: 网络操作相关工具函数
- `config.py`: 配置文件读写工具
- `export.py`: 支持CSV、JSON、Excel等格式的数据导出功能
- `logger.py`: 日志记录工具
- `validators.py`: 数据验证工具
- `security.py`: 安全相关工具

**实用工具特点**：

- 无状态、纯函数式设计
- 每个工具函数专注于单一职责
- 完善的错误处理和边界检查
- 详细的文档字符串
- 全面的单元测试覆盖

#### 3.3.6 配置目录

- `config/`: 全局配置文件目录，包含`settings.ini`和`logging.ini`
- `configs/`: 插件和特定功能的配置文件目录，如`plugins/`下的各种JSON配置

**配置文件示例**：

```ini
# settings.ini 示例
[General]
log_level = INFO
result_dir = results
enable_plugins = true

[Network]
max_threads = 10
connection_timeout = 30
retry_attempts = 3
```

```json
// fingerprintscanner.json 示例
{
  "name": "FingerprintScanner",
  "enabled": true,
  "version": "1.0.0",
  "settings": {
    "timeout": 10,
    "user_agent": "Mozilla/5.0 ...",
    "detection_mode": "aggressive"
  }
}
```

#### 3.3.7 Web与守护进程目录

- `web/`: Web界面实现，包括服务器、API和前端资源
- `daemon/`: 守护进程实现，支持在服务器上长期运行

**Web架构**：

```
Flask应用 -> 路由处理 -> API控制器 -> 核心服务调用 -> 结果格式化 -> JSON响应
```

**守护进程架构**：

```
进程管理器 -> 配置加载 -> 服务初始化 -> 定时任务调度 -> 扫描执行 -> 结果处理 -> 通知
```

### 3.4 文件命名规范

项目采用以下命名规范：

1. **Python文件**: 使用小写字母，单词之间用下划线分隔，如`base_scanner.py`
2. **类名**: 使用驼峰命名法，如`BaseScanner`、`HostScanPanel`
3. **函数和方法**: 使用小写字母，单词之间用下划线分隔，如`validate_config()`
4. **常量**: 使用大写字母，单词之间用下划线分隔，如`MAX_THREADS`
5. **配置文件**:
   - 插件配置使用小写字母，如`fingerprintscanner.json`
   - 主配置文件为`settings.ini`

**文件类型和命名模式**：

| 文件类型 | 命名模式 | 示例 |
|---------|----------|------|
| 模块文件 | 小写+下划线 | `host_scan.py` |
| 类定义文件 | 通常以主类名小写命名 | `base_scanner.py` |
| 配置文件(INI) | 小写+下划线 | `settings.ini` |
| 配置文件(JSON) | 小写无分隔符 | `wafdetector.json` |
| 测试文件 | `test_`前缀 | `test_host_scan.py` |
| 资源文件 | 小写+下划线 | `dark_theme.css` |

### 3.5 模块依赖关系

项目的主要模块依赖关系如下：

```
             +------------+
             |    Web     |
             +-----+------+
                   |
+--------+    +----+----+    +----------+
|  CLI   +--->|   Core   |<---+   GUI    |
+--------+    +----+-----+    +----------+
                   |
                   v
       +------+----+----+------+
       |      |         |      |
+------+--+ +-+------+ ++------+-+
| Plugins | | Utils  | | Config  |
+-----+---+ +--------+ +---------+
      |
      v
+-----------+
| 3rd-party |
+-----------+
```

**详细依赖说明**：

1. **表现层依赖**：
   - GUI依赖于Core，但Core不依赖GUI
   - CLI依赖于Core，但Core不依赖CLI
   - Web依赖于Core，但Core不依赖Web
   - 表现层之间没有相互依赖

2. **核心层依赖**：
   - Core依赖于Utils和Config
   - Core不直接依赖第三方库，通过Utils进行隔离
   - Plugins依赖于Core，扩展Core功能

3. **基础层依赖**：
   - Utils可能依赖一些第三方库
   - Config不应依赖其他模块
   - 避免基础层之间的循环依赖

**依赖管理原则**：

1. **单向依赖**：依赖方向自上而下，避免循环依赖
2. **接口隔离**：通过接口和抽象类隔离模块实现
3. **依赖注入**：使用依赖注入模式传递依赖
4. **最小依赖**：每个模块只依赖必要的其他模块
5. **依赖可视化**：定期审查并可视化项目依赖图

### 3.6 代码组织最佳实践

#### 3.6.1 模块划分原则

1. **按功能划分**：相关功能组织在同一模块
2. **按层次划分**：UI、业务逻辑、数据访问分层
3. **按变化频率划分**：变化频率相似的代码组织在一起
4. **按重用性划分**：可重用组件放在独立模块

#### 3.6.2 代码组织模式

1. **功能组件模式**：
   ```
   module/
     __init__.py
     models.py      # 数据模型
     views.py       # 视图/界面
     controllers.py # 控制器/逻辑
     utils.py       # 工具函数
   ```

2. **领域驱动模式**：
   ```
   domain/
     __init__.py
     entities.py    # 领域实体
     services.py    # 领域服务
     repositories.py # 数据仓库
     events.py      # 领域事件
   ```

3. **特性导向模式**：
   ```
   features/
     host_scanning/
       __init__.py
       scanner.py
       ui.py
       tests.py
   ```

#### 3.6.3 资源管理策略

1. **配置文件**：集中管理在config目录，按模块分类
2. **静态资源**：放在各模块内的resources目录
3. **临时数据**：统一存放在results/cache目录
4. **日志文件**：集中存放在logs目录，按模块分类
5. **数据库文件**：存放在data目录（如使用SQLite）

#### 3.6.4 导入规范

```python
# 标准库导入
import os
import sys
import logging

# 第三方库导入
import numpy as np
import pandas as pd

# 项目内模块导入
from core.base_scanner import BaseScanner
from utils.network import is_valid_ip
```

### 3.7 版本控制和协作

#### 3.7.1 Git分支模型

项目采用GitHub Flow分支模型：

1. **master分支**：稳定发布版本，受保护分支
2. **develop分支**：开发主分支，集成测试通过的功能
3. **feature分支**：新功能开发，命名为`feature/xxx`
4. **bugfix分支**：Bug修复，命名为`bugfix/xxx`
5. **release分支**：发布准备，命名为`release/vX.Y.Z`

#### 3.7.2 版本号规范

遵循语义化版本（Semantic Versioning）：

- **主版本号**：不兼容的API变更
- **次版本号**：向后兼容的功能性新增
- **修订号**：向后兼容的问题修正

例如：v1.2.3

#### 3.7.3 提交消息规范

```
<type>(<scope>): <subject>

<body>

<footer>
```

- **type**: feat, fix, docs, style, refactor, test, chore
- **scope**: 影响范围，如core, gui, cli等
- **subject**: 简短描述
- **body**: 详细描述
- **footer**: 关闭issue等信息

示例：
```
feat(core): 添加TCP Ping扫描功能

实现通过TCP握手进行Ping测试的功能，适用于ICMP被阻止的环境。
- 支持自定义端口
- 添加超时配置
- 实现结果统计

Closes #123
```

## 4. 核心模块

### 4.1 基础扫描器

`core/base_scanner.py` 定义了所有扫描器的基类和扫描结果的数据结构，是整个系统的核心基础。

#### 4.1.1 ScanResult 数据类

```python
@dataclass
class ScanResult:
    """扫描结果数据类"""
    success: bool                  # 扫描是否成功
    data: List[Dict[str, Any]]     # 扫描结果数据列表
    error_msg: Optional[str] = None  # 错误信息
    start_time: float = 0.0        # 扫描开始时间
    end_time: float = 0.0          # 扫描结束时间
    metadata: Dict[str, Any] = None  # 元数据
    
    @property
    def duration(self) -> float:
        """返回扫描持续时间（秒）"""
        return self.end_time - self.start_time
    
    @property
    def record_count(self) -> int:
        """返回结果记录数量"""
        return len(self.data)
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式，用于序列化"""
        # 实现代码...
```

`ScanResult` 数据类封装了扫描结果的基本信息，包括：
- 成功标志
- 结果数据列表
- 错误信息
- 时间信息
- 元数据

它还提供了计算扫描时长和结果记录数的属性方法，以及转换为字典格式的方法，便于序列化和导出。

#### 4.1.2 BaseScanner 抽象基类

```python
class BaseScanner(abc.ABC):
    """
    扫描器基类
    所有网络工具模块都应继承此类并实现其抽象方法
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        """初始化扫描器"""
        self.module_name = self.__class__.__name__
        self.config = config or {}
        self.logger = logging.getLogger(f"scanner.{self.module_name}")
        self.task_id = str(uuid.uuid4())
        self.result = None
        self.running = False
        self.progress_callback = None
    
    def set_progress_callback(self, callback: Callable[[int, str], None]) -> None:
        """设置进度回调函数"""
        self.progress_callback = callback
    
    def update_progress(self, percent: int, message: str) -> None:
        """更新进度信息"""
        if self.progress_callback:
            self.progress_callback(percent, message)
        self.logger.debug(f"Progress: {percent}%, {message}")
    
    @abc.abstractmethod
    def validate_config(self) -> Tuple[bool, Optional[str]]:
        """验证配置参数是否有效"""
        pass
    
    @abc.abstractmethod
    def run_scan(self) -> ScanResult:
        """执行扫描操作"""
        pass
    
    def execute(self) -> ScanResult:
        """执行扫描并返回结果"""
        # 扫描前检查
        if self.running:
            self.logger.warning(f"Scanner {self.module_name} is already running")
            return ScanResult(success=False, data=[], 
                             error_msg=f"Scanner {self.module_name} is already running")
        
        # 设置状态和记录日志
        self.running = True
        self.logger.info(f"Starting {self.module_name} scan with task_id: {self.task_id}")
        self.update_progress(0, f"正在启动 {self.module_name} 扫描...")
        
        # 验证配置
        is_valid, error_msg = self.validate_config()
        if not is_valid:
            self.logger.error(f"Configuration validation failed: {error_msg}")
            self.running = False
            return ScanResult(success=False, data=[], error_msg=error_msg)
        
        # 执行扫描
        try:
            self.update_progress(5, "验证配置成功，开始扫描...")
            start_time = time.time()
            result = self.run_scan()
            end_time = time.time()
            
            # 更新时间信息
            result.start_time = start_time
            result.end_time = end_time
            
            # 记录结果
            self.result = result
            self.logger.info(f"Scan completed: {self.module_name}, records: {result.record_count}, "
                           f"duration: {result.duration:.2f}s")
            
            # 最终进度更新
            if result.success:
                self.update_progress(100, f"扫描完成，获取到 {result.record_count} 条记录")
            else:
                self.update_progress(100, f"扫描失败: {result.error_msg}")
            
            return result
        except Exception as e:
            # 异常处理
            self.logger.error(f"Scan failed: {str(e)}", exc_info=True)
            self.update_progress(100, f"扫描异常: {str(e)}")
            return ScanResult(success=False, data=[], error_msg=f"Scan error: {str(e)}",
                             start_time=time.time(), end_time=time.time())
        finally:
            # 清理状态
            self.running = False
    
    def stop(self) -> None:
        """停止扫描"""
        if self.running:
            self.logger.info(f"Stopping scan: {self.module_name}")
            self.update_progress(100, "扫描已停止")
            self.running = False
    
    @classmethod
    def get_scanner_info(cls) -> Dict[str, Any]:
        """获取扫描器基本信息"""
        return {
            "name": cls.__name__,
            "description": cls.__doc__.strip() if cls.__doc__ else "No description",
            "version": getattr(cls, "VERSION", "1.0.0")
        }
```

`BaseScanner` 类是所有扫描器的抽象基类，定义了扫描器的通用接口和功能：

- **初始化**：设置配置、日志记录器、任务ID等
- **进度回调**：通过 `set_progress_callback` 和 `update_progress` 实现进度通知
- **抽象方法**：
  - `validate_config`: 子类必须实现，验证配置参数
  - `run_scan`: 子类必须实现，执行实际的扫描逻辑
- **执行控制**：
  - `execute`: 封装了完整的扫描流程，包括前置检查、配置验证、扫描执行、结果处理和异常处理
  - `stop`: 提供停止扫描的机制
- **元信息**：通过 `get_scanner_info` 获取扫描器的基本信息

### 4.2 扫描器管理器

`core/scanner_manager.py` 实现了扫描器的注册、查找和创建功能：

```python
class ScannerManager:
    """扫描器管理器"""
    
    def __init__(self):
        self.scanners = {}
        self.logger = logging.getLogger("scanner.manager")
        self._load_scanners()
    
    def _load_scanners(self):
        """加载所有扫描器"""
        # 自动发现并注册core目录下的所有扫描器
        # ...
    
    def register_scanner(self, scanner_class):
        """注册扫描器类"""
        name = scanner_class.__name__
        self.scanners[name] = scanner_class
        self.logger.debug(f"Registered scanner: {name}")
    
    def get_scanner_class(self, name):
        """根据名称获取扫描器类"""
        return self.scanners.get(name)
    
    def create_scanner(self, name, config=None):
        """创建扫描器实例"""
        scanner_class = self.get_scanner_class(name)
        if scanner_class:
            return scanner_class(config)
        return None
    
    def get_available_scanners(self):
        """获取所有可用扫描器"""
        return {name: cls.get_scanner_info() for name, cls in self.scanners.items()}
```

扫描器管理器通过工厂模式实现扫描器的动态创建，主要功能包括：

- 自动发现和加载扫描器类
- 注册扫描器类
- 根据名称获取扫描器类或创建实例
- 提供可用扫描器列表

### 4.3 主要扫描模块

#### 4.3.1 主机扫描器 (`host_scan.py`)

主机扫描器用于发现局域网或指定IP范围内的活跃主机。

**主要功能**：
- 支持ARP、ICMP、TCP多种扫描方式
- 自动识别MAC地址和厂商信息
- 尝试识别操作系统类型
- 可选并发扫描提高效率

**实现要点**：
```python
class HostScanner(BaseScanner):
    """主机扫描器实现"""
    
    def validate_config(self):
        """验证IP范围、扫描方法等参数"""
        # ...
    
    def run_scan(self):
        """执行主机扫描"""
        # 选择扫描方法（ARP/ICMP/TCP）
        if self.config.get('method') == 'arp':
            return self._arp_scan()
        elif self.config.get('method') == 'icmp':
            return self._icmp_scan()
        elif self.config.get('method') == 'tcp':
            return self._tcp_scan()
        # ...
    
    def _arp_scan(self):
        """ARP扫描实现"""
        # 使用Scapy发送ARP请求
        # ...
    
    def _icmp_scan(self):
        """ICMP Ping扫描实现"""
        # 使用ICMP Echo请求
        # ...
    
    def _tcp_scan(self):
        """TCP SYN扫描实现"""
        # 尝试连接常用端口判断主机存活
        # ...
```

#### 4.3.2 端口扫描器 (`port_scan.py`)

端口扫描器用于检测目标主机开放的端口和服务。

**主要功能**：
- 支持TCP Connect、TCP SYN、UDP等扫描方式
- 服务版本识别
- 常见端口服务指纹匹配
- 可自定义端口范围和扫描速率

**实现要点**：
```python
class PortScanner(BaseScanner):
    """端口扫描器实现"""
    
    def validate_config(self):
        """验证目标主机和端口范围"""
        # ...
    
    def run_scan(self):
        """执行端口扫描"""
        # 根据配置选择扫描方法
        # ...
    
    def _tcp_connect_scan(self, target, ports):
        """TCP Connect扫描"""
        # 使用socket尝试连接
        # ...
    
    def _tcp_syn_scan(self, target, ports):
        """TCP SYN扫描（半开放扫描）"""
        # 使用Scapy发送SYN包
        # ...
    
    def _service_detection(self, target, port):
        """服务版本检测"""
        # 发送探测包并分析响应
        # ...
```

#### 4.3.3 DNS检测器 (`dns_check.py`)

DNS检测器用于域名解析和DNS记录查询。

**主要功能**：
- 查询各类DNS记录(A, AAAA, MX, NS, CNAME等)
- 子域名枚举
- DNS服务器检测
- DNS配置分析

**实现要点**：
```python
class DNSChecker(BaseScanner):
    """DNS检测实现"""
    
    def validate_config(self):
        """验证域名和查询类型"""
        # ...
    
    def run_scan(self):
        """执行DNS查询"""
        # 根据查询类型调用不同方法
        # ...
    
    def _query_record(self, domain, record_type):
        """查询特定类型的DNS记录"""
        # 使用dnspython查询
        # ...
    
    def _enumerate_subdomains(self, domain, wordlist):
        """子域名枚举"""
        # 遍历字典尝试解析子域名
        # ...
```

#### 4.3.4 路由追踪器 (`traceroute.py`)

路由追踪器用于分析数据包从源到目标经过的网络路径。

**主要功能**：
- 支持ICMP、UDP、TCP多种追踪方式
- 显示每一跳的IP和响应时间
- 尝试解析路由器主机名
- 提供地理位置信息（可选）

**实现要点**：
```python
class Tracerouter(BaseScanner):
    """路由追踪实现"""
    
    def validate_config(self):
        """验证目标和最大跳数"""
        # ...
    
    def run_scan(self):
        """执行路由追踪"""
        # 选择追踪方法
        # ...
    
    def _icmp_trace(self, target, max_hops):
        """使用ICMP进行追踪"""
        # 逐步增加TTL值发送ICMP包
        # ...
    
    def _tcp_trace(self, target, port, max_hops):
        """使用TCP进行追踪"""
        # 发送TCP SYN包并增加TTL
        # ...
```

#### 4.3.5 Ping监控器 (`ping_monitor.py`)

Ping监控器用于长期监控目标主机的可达性和网络质量。

**主要功能**：
- 连续Ping测试
- 统计响应时间和丢包率
- 设置告警阈值
- 生成统计报告和图表

**实现要点**：
```python
class PingMonitor(BaseScanner):
    """Ping监控实现"""
    
    def validate_config(self):
        """验证目标和监控参数"""
        # ...
    
    def run_scan(self):
        """执行Ping监控"""
        # 根据配置执行监控
        # ...
    
    def _ping_target(self, target, count):
        """对目标执行Ping测试"""
        # 使用ICMP Echo请求
        # ...
    
    def _analyze_results(self, results):
        """分析Ping结果"""
        # 计算平均/最小/最大响应时间和丢包率
        # ...
```

#### 4.3.6 Web目录扫描器 (`web_dir_scan.py`)

Web目录扫描器用于发现Web应用的目录和文件。

**主要功能**：
- 字典式目录和文件探测
- 支持自定义字典
- 识别返回状态和内容特征
- 支持多线程扫描

**实现要点**：
```python
class WebDirScanner(BaseScanner):
    """Web目录扫描实现"""
    
    def validate_config(self):
        """验证目标URL和扫描参数"""
        # ...
    
    def run_scan(self):
        """执行Web目录扫描"""
        # 加载字典并执行扫描
        # ...
    
    def _load_dictionary(self, dict_path):
        """加载扫描字典"""
        # 读取字典文件
        # ...
    
    def _scan_url(self, base_url, path):
        """扫描单个URL路径"""
        # 发送HTTP请求并分析响应
        # ...
```

#### 4.3.7 Web风险扫描器 (`web_risk_scan.py`)

Web风险扫描器用于检测Web应用的安全配置和常见漏洞。

**主要功能**：
- Web服务器指纹识别
- WAF(Web应用防火墙)检测
- HTTP安全响应头分析
- 常见漏洞探测（XSS、SQL注入等）

**实现要点**：
```python
class WebRiskScanner(BaseScanner):
    """Web风险扫描实现"""
    
    def validate_config(self):
        """验证目标URL和扫描选项"""
        # ...
    
    def run_scan(self):
        """执行Web风险扫描"""
        # 根据配置执行不同类型的安全检查
        # ...
    
    def _fingerprint_server(self, url):
        """识别Web服务器和技术栈"""
        # 分析HTTP响应头和页面内容
        # ...
    
    def _check_security_headers(self, url):
        """检查HTTP安全响应头配置"""
        # 检查各类安全相关HTTP头
        # ...
    
    def _detect_waf(self, url):
        """检测WAF存在"""
        # 发送特殊请求判断WAF特征
        # ...
    
    def _vulnerability_scan(self, url):
        """基本漏洞扫描"""
        # 尝试探测XSS、SQL注入等漏洞
        # ...
```

### 4.4 扫描模块通用设计原则

所有扫描模块遵循以下通用设计原则：

1. **继承基类**：继承`BaseScanner`并实现其抽象方法
2. **配置验证**：在`validate_config`中严格检查输入参数
3. **错误处理**：使用try-except捕获异常，提供明确的错误消息
4. **进度更新**：定期调用`update_progress`通知调用者当前进度
5. **可中断设计**：定期检查`self.running`标志，支持优雅停止
6. **模块化结构**：将复杂功能分解为多个私有方法
7. **详细日志**：使用logger记录关键操作和错误
8. **资源管理**：确保资源（如文件、网络连接）正确释放

## 5. 用户界面

### 5.1 命令行界面 (CLI)

命令行界面提供了一种快捷、可脚本化的方式使用各种扫描功能。CLI实现位于`cli/main.py`。

#### 5.1.1 命令结构

CLI采用子命令结构设计：

```
nettools-cli <command> [options]
```

主要命令包括：

- `list`: 列出所有可用的扫描模块
- `run`: 运行特定的扫描模块
- `config`: 管理全局配置
- `version`: 显示版本信息
- `help`: 显示帮助信息

#### 5.1.2 命令行参数处理

CLI使用`argparse`库处理命令行参数：

```python
def main():
    """命令行入口函数"""
    parser = argparse.ArgumentParser(
        description="NetTools - 网络扫描工具集",
        prog="nettools-cli"
    )
    
    # 创建子命令解析器
    subparsers = parser.add_subparsers(dest="command", help="可用命令")
    
    # list命令
    list_parser = subparsers.add_parser("list", help="列出可用模块")
    
    # run命令
    run_parser = subparsers.add_parser("run", help="运行扫描模块")
    run_parser.add_argument("module", help="要运行的模块名称")
    
    # 为每个模块添加特定参数
    _add_module_arguments(run_parser)
    
    # config命令
    config_parser = subparsers.add_parser("config", help="管理配置")
    config_parser.add_argument("action", choices=["show", "set", "reset"],
                              help="配置操作")
    
    # 解析参数并执行
    args = parser.parse_args()
    
    # 根据子命令分发处理
    if args.command == "list":
        _handle_list_command()
    elif args.command == "run":
        _handle_run_command(args)
    elif args.command == "config":
        _handle_config_command(args)
    else:
        parser.print_help()
```

#### 5.1.3 模块参数动态加载

CLI能够动态识别每个扫描模块支持的特定参数：

```python
def _add_module_arguments(parser):
    """为每个模块添加特定的命令行参数"""
    # 创建模块子解析器
    module_parsers = parser.add_subparsers(dest="module")
    
    # 为每个扫描模块添加特定参数
    # 主机扫描模块
    host_parser = module_parsers.add_parser("hostscanner", help="主机扫描")
    host_parser.add_argument("--ip_range", required=True, help="IP地址范围，如192.168.1.0/24")
    host_parser.add_argument("--method", choices=["arp", "icmp", "tcp"], default="icmp",
                           help="扫描方法")
    
    # 端口扫描模块
    port_parser = module_parsers.add_parser("portscanner", help="端口扫描")
    port_parser.add_argument("--target", required=True, help="目标主机IP或域名")
    port_parser.add_argument("--ports", default="1-1000", help="端口范围，如1-1000或common")
    
    # ... 其他模块的参数 ...
```

#### 5.1.4 执行流程

运行扫描模块的处理流程：

```python
def _handle_run_command(args):
    """处理run命令"""
    # 获取模块名和参数
    module_name = args.module
    
    # 从参数构建配置字典
    config = vars(args)
    
    # 创建扫描器实例
    scanner_manager = ScannerManager()
    scanner = scanner_manager.create_scanner(module_name, config)
    
    if not scanner:
        print(f"错误: 未找到模块 '{module_name}'")
        return
    
    # 设置进度回调
    scanner.set_progress_callback(_progress_callback)
    
    # 执行扫描
    print(f"正在执行 {module_name} 扫描...")
    result = scanner.execute()
    
    # 处理结果
    if result.success:
        print(f"扫描完成: 找到 {result.record_count} 条记录")
        _display_results(result)
    else:
        print(f"扫描失败: {result.error_msg}")
```

#### 5.1.5 结果输出与格式化

CLI支持多种格式的结果输出：

```python
def _display_results(result, format="table"):
    """显示扫描结果"""
    if format == "table":
        # 表格形式显示（使用prettytable或类似库）
        _display_as_table(result.data)
    elif format == "json":
        # JSON格式输出
        print(json.dumps(result.to_dict(), indent=2))
    
    # 如果指定了输出文件，保存结果
    if output_file:
        _save_results(result, output_file)
```

### 5.2 图形用户界面 (GUI)

图形用户界面使用PyQt5实现，提供直观的操作方式和可视化结果展示。

#### 5.2.1 主窗口

`gui/main.py` 实现应用程序主窗口：

```python
class MainWindow(QMainWindow):
    """主应用窗口"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("NetTools - 网络扫描工具箱")
        self.setMinimumSize(800, 600)
        
        # 初始化UI组件
        self.init_ui()
        
        # 加载配置
        self.config_manager = ConfigManager()
        
        # 创建状态栏
        self.statusBar().showMessage("就绪")
    
    def init_ui(self):
        """初始化UI组件"""
        # 创建菜单栏
        self.create_menu_bar()
        
        # 创建中央窗口部件和标签页
        self.central_widget = QTabWidget()
        self.setCentralWidget(self.central_widget)
        
        # 加载功能面板
        self.load_panels()
    
    def create_menu_bar(self):
        """创建菜单栏"""
        menubar = self.menuBar()
        
        # 文件菜单
        file_menu = menubar.addMenu("文件")
        
        # 配置菜单项
        config_action = QAction("配置", self)
        config_action.triggered.connect(self.open_config_editor)
        file_menu.addAction(config_action)
        
        # 退出菜单项
        exit_action = QAction("退出", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # 帮助菜单
        help_menu = menubar.addMenu("帮助")
        
        # 关于菜单项
        about_action = QAction("关于", self)
        about_action.triggered.connect(self.show_about_dialog)
        help_menu.addAction(about_action)
    
    def load_panels(self):
        """加载功能面板"""
        # 添加主机扫描面板
        self.host_scan_panel = HostScanPanel(self)
        self.central_widget.addTab(self.host_scan_panel, "主机扫描")
        
        # 添加端口扫描面板
        self.port_scan_panel = PortScanPanel(self)
        self.central_widget.addTab(self.port_scan_panel, "端口扫描")
        
        # ... 添加其他功能面板 ...
```

#### 5.2.2 面板基类

`gui/panels/base_panel.py` 定义了所有功能面板的基类：

```python
class BasePanel(QWidget):
    """功能面板基类"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.scanner = None
        self.scan_thread = None
        self.result = None
        
        # 初始化UI
        self.init_ui()
    
    def init_ui(self):
        """初始化UI组件"""
        # 主布局
        self.main_layout = QVBoxLayout()
        self.setLayout(self.main_layout)
        
        # 控制区域
        self.control_area = self.create_control_area()
        self.main_layout.addWidget(self.control_area)
        
        # 结果区域
        self.result_area = self.create_result_area()
        self.main_layout.addWidget(self.result_area)
        
        # 状态和进度区域
        self.status_area = self.create_status_area()
        self.main_layout.addWidget(self.status_area)
    
    def create_control_area(self):
        """创建控制区域（参数设置和操作按钮）"""
        # 子类应重写此方法
        control_group = QGroupBox("控制")
        layout = QVBoxLayout()
        control_group.setLayout(layout)
        return control_group
    
    def create_result_area(self):
        """创建结果显示区域"""
        # 子类应重写此方法
        result_group = QGroupBox("结果")
        layout = QVBoxLayout()
        
        # 默认使用表格显示
        self.result_table = QTableWidget()
        layout.addWidget(self.result_table)
        
        result_group.setLayout(layout)
        return result_group
    
    def create_status_area(self):
        """创建状态和进度区域"""
        status_group = QGroupBox("状态")
        layout = QHBoxLayout()
        
        # 状态信息
        self.status_label = QLabel("就绪")
        layout.addWidget(self.status_label)
        
        # 进度条
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)
        
        # 控制按钮
        self.start_button = QPushButton("开始扫描")
        self.start_button.clicked.connect(self.start_scan)
        layout.addWidget(self.start_button)
        
        self.stop_button = QPushButton("停止")
        self.stop_button.clicked.connect(self.stop_scan)
        self.stop_button.setEnabled(False)
        layout.addWidget(self.stop_button)
        
        status_group.setLayout(layout)
        return status_group
    
    def start_scan(self):
        """开始扫描操作"""
        # 获取配置参数（子类应实现获取参数的方法）
        config = self.get_config()
        
        # 创建扫描线程
        self.scan_thread = ScanThread(self.scanner_class, config)
        
        # 连接信号
        self.scan_thread.progress_update.connect(self.update_progress)
        self.scan_thread.scan_complete.connect(self.on_scan_complete)
        
        # 更新UI状态
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.status_label.setText("扫描中...")
        
        # 启动线程
        self.scan_thread.start()
    
    def stop_scan(self):
        """停止扫描操作"""
        if self.scan_thread and self.scan_thread.isRunning():
            self.status_label.setText("正在停止...")
            self.scan_thread.stop()
    
    def update_progress(self, percent, message):
        """更新进度信息"""
        self.progress_bar.setValue(percent)
        self.status_label.setText(message)
    
    def on_scan_complete(self, result):
        """扫描完成处理"""
        self.result = result
        
        # 更新UI状态
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        
        if result.success:
            self.status_label.setText(f"扫描完成: {result.record_count}条记录")
            self.display_results(result)
        else:
            self.status_label.setText(f"扫描失败: {result.error_msg}")
    
    def display_results(self, result):
        """显示扫描结果（子类应重写此方法）"""
        pass
    
    def get_config(self):
        """获取配置参数（子类应重写此方法）"""
        return {}
```

#### 5.2.3 扫描线程

为保持UI响应性，扫描操作通过独立的工作线程执行：

```python
class ScanThread(QThread):
    """扫描线程类"""
    
    # 自定义信号
    progress_update = pyqtSignal(int, str)  # 进度更新信号
    scan_complete = pyqtSignal(object)  # 扫描完成信号
    
    def __init__(self, scanner_class, config):
        super().__init__()
        self.scanner_class = scanner_class
        self.config = config
        self.scanner = None
    
    def run(self):
        """线程主函数"""
        # 创建扫描器实例
        self.scanner = self.scanner_class(self.config)
        
        # 设置进度回调函数
        self.scanner.set_progress_callback(self._progress_callback)
        
        # 执行扫描
        result = self.scanner.execute()
        
        # 发出扫描完成信号
        self.scan_complete.emit(result)
    
    def _progress_callback(self, percent, message):
        """进度回调函数"""
        self.progress_update.emit(percent, message)
    
    def stop(self):
        """停止扫描"""
        if self.scanner:
            self.scanner.stop()
```

#### 5.2.4 功能面板实现

每个扫描功能都有对应的GUI面板实现，下面以主机扫描面板为例：

```python
class HostScanPanel(BasePanel):
    """主机扫描面板"""
    
    def __init__(self, parent=None):
        # 设置扫描器类
        self.scanner_class = HostScanner
        super().__init__(parent)
    
    def create_control_area(self):
        """创建控制区域"""
        control_group = QGroupBox("扫描参数")
        form_layout = QFormLayout()
        
        # IP范围输入
        self.ip_range_input = QLineEdit()
        form_layout.addRow("IP范围:", self.ip_range_input)
        
        # 扫描方法选择
        self.method_combo = QComboBox()
        self.method_combo.addItems(["icmp", "arp", "tcp"])
        form_layout.addRow("扫描方法:", self.method_combo)
        
        # 高级选项
        self.advanced_options = QGroupBox("高级选项")
        self.advanced_options.setCheckable(True)
        self.advanced_options.setChecked(False)
        
        # 高级选项布局
        advanced_layout = QFormLayout()
        
        # 超时设置
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(1, 30)
        self.timeout_spin.setValue(2)
        advanced_layout.addRow("超时(秒):", self.timeout_spin)
        
        # 线程数设置
        self.threads_spin = QSpinBox()
        self.threads_spin.setRange(1, 100)
        self.threads_spin.setValue(10)
        advanced_layout.addRow("线程数:", self.threads_spin)
        
        self.advanced_options.setLayout(advanced_layout)
        form_layout.addRow(self.advanced_options)
        
        control_group.setLayout(form_layout)
        return control_group
    
    def create_result_area(self):
        """创建结果显示区域"""
        result_group = QGroupBox("扫描结果")
        layout = QVBoxLayout()
        
        # 选项卡
        result_tabs = QTabWidget()
        
        # 表格视图
        self.result_table = QTableWidget()
        self.result_table.setColumnCount(4)
        self.result_table.setHorizontalHeaderLabels(["IP地址", "MAC地址", "主机名", "状态"])
        result_tabs.addTab(self.result_table, "表格视图")
        
        # 拓扑视图
        self.topology_view = HostTopologyView()
        result_tabs.addTab(self.topology_view, "拓扑图")
        
        layout.addWidget(result_tabs)
        
        # 导出按钮
        export_layout = QHBoxLayout()
        
        self.export_csv_btn = QPushButton("导出CSV")
        self.export_csv_btn.clicked.connect(lambda: self.export_results("csv"))
        export_layout.addWidget(self.export_csv_btn)
        
        self.export_json_btn = QPushButton("导出JSON")
        self.export_json_btn.clicked.connect(lambda: self.export_results("json"))
        export_layout.addWidget(self.export_json_btn)
        
        layout.addLayout(export_layout)
        
        result_group.setLayout(layout)
        return result_group
    
    def get_config(self):
        """获取配置参数"""
        config = {
            "ip_range": self.ip_range_input.text(),
            "method": self.method_combo.currentText(),
            "timeout": self.timeout_spin.value(),
            "threads": self.threads_spin.value()
        }
        return config
    
    def display_results(self, result):
        """显示扫描结果"""
        # 清空表格
        self.result_table.setRowCount(0)
        
        # 添加数据行
        for i, host in enumerate(result.data):
            self.result_table.insertRow(i)
            self.result_table.setItem(i, 0, QTableWidgetItem(host.get("ip", "")))
            self.result_table.setItem(i, 1, QTableWidgetItem(host.get("mac", "")))
            self.result_table.setItem(i, 2, QTableWidgetItem(host.get("hostname", "")))
            self.result_table.setItem(i, 3, QTableWidgetItem(host.get("status", "")))
        
        # 更新拓扑图
        self.topology_view.update_topology(result.data)
    
    def export_results(self, format):
        """导出结果"""
        if not self.result or not self.result.data:
            QMessageBox.warning(self, "警告", "没有可导出的结果数据")
            return
        
        # 获取保存文件路径
        filename, _ = QFileDialog.getSaveFileName(
            self, "保存结果", "", 
            "CSV文件 (*.csv);;JSON文件 (*.json);;所有文件 (*.*)"
        )
        
        if not filename:
            return
        
        # 执行导出
        try:
            if format == "csv":
                ExportUtility.export_to_csv(self.result.data, filename)
            elif format == "json":
                ExportUtility.export_to_json(self.result.to_dict(), filename)
            
            QMessageBox.information(self, "导出成功", f"结果已成功导出到 {filename}")
        except Exception as e:
            QMessageBox.critical(self, "导出失败", f"导出过程中出错: {str(e)}")
```

#### 5.2.5 网络拓扑可视化

`gui/host_topology_networkx.py` 实现网络拓扑图的可视化：

```python
class HostTopologyView(QWidget):
    """主机拓扑图视图"""
    
    def __init__(self):
        super().__init__()
        self.graph = nx.Graph()
        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)
        
        # 工具栏
        self.toolbar = NavigationToolbar(self.canvas, self)
        
        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        self.setLayout(layout)
        
        # 布局算法选择
        self.layout_combo = QComboBox()
        self.layout_combo.addItems(["Spring", "Circular", "Shell", "Kamada-Kawai"])
        self.layout_combo.currentIndexChanged.connect(self.redraw_topology)
        
        layout.addWidget(QLabel("布局算法:"))
        layout.addWidget(self.layout_combo)
        
        # 初始化空拓扑图
        self.clear_topology()
    
    def update_topology(self, hosts_data):
        """更新拓扑图数据"""
        # 创建新图
        self.graph = nx.Graph()
        
        # 添加节点
        for host in hosts_data:
            ip = host.get("ip", "")
            if ip:
                self.graph.add_node(ip)
        
        # 尝试添加边（基于ARP表或者网络前缀等）
        # ...
        
        # 绘制图
        self.redraw_topology()
    
    def redraw_topology(self):
        """重绘拓扑图"""
        # 清空现有图
        self.figure.clear()
        
        # 没有数据时显示提示
        if not self.graph.nodes():
            ax = self.figure.add_subplot(111)
            ax.text(0.5, 0.5, "没有可显示的拓扑数据", ha="center", va="center")
            ax.axis("off")
            self.canvas.draw()
            return
        
        # 选择布局算法
        layout_name = self.layout_combo.currentText()
        if layout_name == "Spring":
            pos = nx.spring_layout(self.graph)
        elif layout_name == "Circular":
            pos = nx.circular_layout(self.graph)
        elif layout_name == "Shell":
            pos = nx.shell_layout(self.graph)
        elif layout_name == "Kamada-Kawai":
            pos = nx.kamada_kawai_layout(self.graph)
        
        # 绘制图
        ax = self.figure.add_subplot(111)
        nx.draw(self.graph, pos, with_labels=True, node_color="skyblue", 
               node_size=700, font_size=8, ax=ax)
        
        # 显示
        self.canvas.draw()
    
    def clear_topology(self):
        """清空拓扑图"""
        self.graph = nx.Graph()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        ax.text(0.5, 0.5, "没有拓扑数据", ha="center", va="center")
        ax.axis("off")
        self.canvas.draw()
```

### 5.3 配置编辑器

`gui/config_editor.py` 实现全局配置文件的编辑界面：

```python
class ConfigEditor(QDialog):
    """配置编辑器对话框"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("全局配置")
        self.setMinimumSize(500, 400)
        
        # 加载配置
        self.config_manager = ConfigManager()
        self.config = self.config_manager.load_config()
        
        self.init_ui()
    
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout()
        
        # 创建选项卡
        self.tab_widget = QTabWidget()
        
        # 通用设置选项卡
        self.general_tab = self.create_general_tab()
        self.tab_widget.addTab(self.general_tab, "通用设置")
        
        # 网络设置选项卡
        self.network_tab = self.create_network_tab()
        self.tab_widget.addTab(self.network_tab, "网络设置")
        
        # 日志设置选项卡
        self.logging_tab = self.create_logging_tab()
        self.tab_widget.addTab(self.logging_tab, "日志设置")
        
        layout.addWidget(self.tab_widget)
        
        # 按钮区域
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel | QDialogButtonBox.Apply | QDialogButtonBox.Reset
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        buttons.button(QDialogButtonBox.Apply).clicked.connect(self.apply_settings)
        buttons.button(QDialogButtonBox.Reset).clicked.connect(self.reset_settings)
        
        layout.addWidget(buttons)
        self.setLayout(layout)
    
    def create_general_tab(self):
        """创建通用设置选项卡"""
        # ...
    
    def create_network_tab(self):
        """创建网络设置选项卡"""
        # ...
    
    def create_logging_tab(self):
        """创建日志设置选项卡"""
        # ...
    
    def apply_settings(self):
        """应用设置"""
        # 从UI收集设置项
        # ...
        
        # 保存配置
        self.config_manager.save_config(self.config)
        QMessageBox.information(self, "保存成功", "配置已成功保存")
    
    def reset_settings(self):
        """重置为默认设置"""
        reply = QMessageBox.question(
            self, "确认重置", "确定要将所有设置重置为默认值吗？",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.config = self.config_manager.get_default_config()
            self.update_ui_from_config()
    
    def update_ui_from_config(self):
        """根据配置更新UI"""
        # ...
    
    def accept(self):
        """确定按钮处理"""
        self.apply_settings()
        super().accept()
```

## 6. 配置管理

配置管理系统负责读取、保存和验证应用程序的配置信息，确保各个模块能够获取正确的配置参数。

### 6.1 全局配置

全局配置文件采用INI格式，存储在`config/settings.ini`中。配置分为多个部分，包含应用程序的全局设置和各模块的默认配置。

#### 6.1.1 配置文件结构

一个典型的`settings.ini`文件结构如下：

```ini
[General]
log_level = INFO
result_dir = results
enable_plugins = true
default_timeout = 5
data_dir = data

[Network]
max_threads = 10
connection_timeout = 30
retry_attempts = 3
scan_delay = 0.5

[Scanner]
default_scan_method = icmp
port_batch_size = 100

[Logging]
log_to_file = true
log_file = logs/nettools.log
log_format = %%(asctime)s - %%(name)s - %%(levelname)s - %%(message)s
log_rotation = 7
```

#### 6.1.2 配置管理类

`utils/config.py` 中的 `ConfigManager` 类负责配置文件的读取和保存：

```python
class ConfigManager:
    """配置管理器"""
    
    def __init__(self, config_file="config/settings.ini"):
        self.config_file = config_file
        self.config = self._load_config()
    
    def _load_config(self):
        """加载配置文件"""
        config = configparser.ConfigParser()
        
        # 检查配置文件是否存在
        if not os.path.exists(self.config_file):
            # 创建默认配置
            self._create_default_config(config)
            # 确保目录存在
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            # 保存默认配置
            with open(self.config_file, 'w') as f:
                config.write(f)
        else:
            # 读取现有配置
            config.read(self.config_file)
        
        return config
    
    def _create_default_config(self, config):
        """创建默认配置"""
        # 通用设置
        config['General'] = {
            'log_level': 'INFO',
            'result_dir': 'results',
            'enable_plugins': 'true',
            'default_timeout': '5',
            'data_dir': 'data'
        }
        
        # 网络设置
        config['Network'] = {
            'max_threads': '10',
            'connection_timeout': '30',
            'retry_attempts': '3',
            'scan_delay': '0.5'
        }
        
        # 扫描器设置
        config['Scanner'] = {
            'default_scan_method': 'icmp',
            'port_batch_size': '100'
        }
        
        # 日志设置
        config['Logging'] = {
            'log_to_file': 'true',
            'log_file': 'logs/nettools.log',
            'log_format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            'log_rotation': '7'
        }
    
    def get_value(self, section, option, default=None):
        """获取配置项值"""
        try:
            return self.config.get(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError):
            return default
    
    def get_int(self, section, option, default=0):
        """获取整数配置项"""
        try:
            return self.config.getint(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError, ValueError):
            return default
    
    def get_float(self, section, option, default=0.0):
        """获取浮点数配置项"""
        try:
            return self.config.getfloat(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError, ValueError):
            return default
    
    def get_boolean(self, section, option, default=False):
        """获取布尔值配置项"""
        try:
            return self.config.getboolean(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError, ValueError):
            return default
    
    def set_value(self, section, option, value):
        """设置配置项值"""
        # 确保section存在
        if not self.config.has_section(section):
            self.config.add_section(section)
        
        # 设置值
        self.config.set(section, option, str(value))
    
    def save_config(self):
        """保存配置到文件"""
        # 确保目录存在
        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
        
        # 保存配置
        with open(self.config_file, 'w') as f:
            self.config.write(f)
    
    def reset_to_default(self):
        """重置为默认配置"""
        # 创建一个新的配置解析器
        config = configparser.ConfigParser()
        
        # 设置默认值
        self._create_default_config(config)
        
        # 更新当前配置
        self.config = config
        
        # 保存到文件
        self.save_config()
```

#### 6.1.3 配置使用方式

在代码中使用全局配置的示例：

```python
# 获取配置管理器实例
config_manager = ConfigManager()

# 读取配置项
log_level = config_manager.get_value('Logging', 'log_level', 'INFO')
max_threads = config_manager.get_int('Network', 'max_threads', 10)
scan_delay = config_manager.get_float('Network', 'scan_delay', 0.5)
enable_plugins = config_manager.get_boolean('General', 'enable_plugins', True)

# 修改配置
config_manager.set_value('Network', 'max_threads', 20)
config_manager.save_config()
```

### 6.2 插件配置

插件配置使用JSON格式，存储在`configs/plugins/`目录下，每个插件对应一个配置文件。

#### 6.2.1 插件配置文件结构

插件配置文件示例 (`configs/plugins/fingerprintscanner.json`):

```json
{
    "name": "FingerprintScanner",
    "enabled": true,
    "version": "1.0.0",
    "description": "Web应用指纹识别插件",
    "settings": {
        "timeout": 10,
        "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36",
        "verify_ssl": true,
        "follow_redirects": true,
        "max_redirects": 5,
        "detection_mode": "aggressive"
    },
    "patterns": [
        {
            "name": "WordPress",
            "path": "/wp-login.php",
            "content": "WordPress",
            "headers": {
                "X-Powered-By": "WordPress"
            }
        },
        {
            "name": "Joomla",
            "path": "/administrator",
            "content": "Joomla"
        }
        // ... 更多模式 ...
    ]
}
```

#### 6.2.2 插件配置管理

`plugins/config_manager.py` 中的 `PluginConfigManager` 类负责插件配置的管理：

```python
class PluginConfigManager:
    """插件配置管理器"""
    
    def __init__(self, config_dir="configs/plugins"):
        self.config_dir = config_dir
        os.makedirs(config_dir, exist_ok=True)
    
    def get_plugin_config(self, plugin_name):
        """获取插件配置"""
        config_file = os.path.join(self.config_dir, f"{plugin_name.lower()}.json")
        
        # 检查配置文件是否存在
        if not os.path.exists(config_file):
            # 返回默认配置
            return self._get_default_config(plugin_name)
        
        # 读取配置文件
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            # 解析失败时返回默认配置
            return self._get_default_config(plugin_name)
    
    def save_plugin_config(self, plugin_name, config):
        """保存插件配置"""
        config_file = os.path.join(self.config_dir, f"{plugin_name.lower()}.json")
        
        # 确保目录存在
        os.makedirs(os.path.dirname(config_file), exist_ok=True)
        
        # 保存配置
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=4)
    
    def _get_default_config(self, plugin_name):
        """获取插件默认配置"""
        # 示例默认配置
        return {
            "name": plugin_name,
            "enabled": True,
            "version": "1.0.0",
            "description": f"{plugin_name} 插件",
            "settings": {}
        }
    
    def get_all_plugin_configs(self):
        """获取所有插件配置"""
        configs = {}
        
        # 遍历插件配置目录
        for filename in os.listdir(self.config_dir):
            if filename.endswith('.json'):
                plugin_name = os.path.splitext(filename)[0]
                configs[plugin_name] = self.get_plugin_config(plugin_name)
        
        return configs
    
    def reset_plugin_config(self, plugin_name):
        """重置插件配置为默认值"""
        default_config = self._get_default_config(plugin_name)
        self.save_plugin_config(plugin_name, default_config)
        return default_config
```

## 7. 插件系统

插件系统允许开发者扩展NetTools的功能，而无需修改核心代码。这种设计使得功能增强更加灵活，也便于第三方开发者贡献新功能。

### 7.1 插件基类

`plugins/base_plugin.py` 定义了插件接口，所有插件都应继承此类：

```python
class BasePlugin(abc.ABC):
    """插件基类
    
    所有NetTools插件都应该继承此类并实现其抽象方法。
    """
    
    def __init__(self, config=None):
        """初始化插件
        
        Args:
            config: 插件配置
        """
        self.config = config or {}
        self.name = self.__class__.__name__
        self.initialized = False
        self.logger = logging.getLogger(f"plugin.{self.name}")
    
    @abc.abstractmethod
    def initialize(self) -> bool:
        """初始化插件
        
        在此方法中进行插件的初始化操作，如加载资源、验证配置等。
        
        Returns:
            bool: 初始化是否成功
        """
        pass
    
    @abc.abstractmethod
    def execute(self, *args, **kwargs) -> Any:
        """执行插件功能
        
        插件的主要功能实现。
        
        Returns:
            Any: 执行结果
        """
        pass
    
    def cleanup(self) -> None:
        """清理资源
        
        在插件卸载或程序退出时调用，用于释放资源。
        """
        pass
    
    @classmethod
    def get_plugin_info(cls) -> Dict[str, Any]:
        """获取插件信息
        
        返回插件的基本信息，如名称、描述等。
        
        Returns:
            Dict: 插件信息字典
        """
        return {
            "name": cls.__name__,
            "description": cls.__doc__.strip() if cls.__doc__ else "No description",
            "version": getattr(cls, "VERSION", "1.0.0"),
            "author": getattr(cls, "AUTHOR", "Unknown"),
            "requires": getattr(cls, "REQUIRES", [])
        }
```

### 7.2 插件管理器

`plugins/plugin_manager.py` 实现了插件的发现、加载和管理：

```python
class PluginManager:
    """插件管理器
    
    负责插件的发现、加载和管理。
    """
    
    def __init__(self, plugins_dir="plugins", config_manager=None):
        """初始化插件管理器
        
        Args:
            plugins_dir: 插件目录
            config_manager: 配置管理器实例
        """
        self.plugins_dir = plugins_dir
        self.plugins = {}  # 已加载的插件: {name: instance}
        self.plugin_classes = {}  # 已注册的插件类: {name: class}
        self.logger = logging.getLogger("plugin.manager")
        
        # 插件配置管理器
        if config_manager:
            self.config_manager = config_manager
        else:
            from plugins.config_manager import PluginConfigManager
            self.config_manager = PluginConfigManager()
        
        # 全局配置管理器
        from utils.config import ConfigManager
        self.global_config = ConfigManager()
        
        # 检查是否启用插件
        self.enabled = self.global_config.get_boolean('General', 'enable_plugins', True)
        
        if self.enabled:
            # 加载插件
            self._discover_plugins()
    
    def _discover_plugins(self):
        """发现并注册插件"""
        # 检查插件目录是否存在
        if not os.path.isdir(self.plugins_dir):
            self.logger.warning(f"插件目录不存在: {self.plugins_dir}")
            return
        
        # 搜索插件模块
        for root, dirs, files in os.walk(self.plugins_dir):
            # 跳过特殊文件夹
            dirs[:] = [d for d in dirs if not d.startswith('_') and not d.startswith('.')]
            
            for file in files:
                # 只处理Python文件且不是特殊文件
                if file.endswith('.py') and not file.startswith('_'):
                    # 构造模块路径
                    rel_path = os.path.relpath(root, os.getcwd())
                    module_path = os.path.join(rel_path, file).replace(os.path.sep, '.')
                    module_name = os.path.splitext(module_path)[0]
                    
                    try:
                        # 导入模块
                        module = importlib.import_module(module_name)
                        
                        # 在模块中查找插件类
                        for attr_name in dir(module):
                            attr = getattr(module, attr_name)
                            
                            # 检查是否是BasePlugin的子类且不是BasePlugin本身
                            if (isinstance(attr, type) and 
                                issubclass(attr, BasePlugin) and 
                                attr is not BasePlugin):
                                # 注册插件类
                                self.register_plugin_class(attr)
                    except ImportError as e:
                        self.logger.error(f"加载插件模块失败: {module_name} - {str(e)}")
    
    def register_plugin_class(self, plugin_class):
        """注册插件类"""
        name = plugin_class.__name__
        self.plugin_classes[name] = plugin_class
        self.logger.debug(f"已注册插件类: {name}")
    
    def load_plugin(self, plugin_name):
        """加载插件实例"""
        # 检查插件是否已加载
        if plugin_name in self.plugins:
            return self.plugins[plugin_name]
        
        # 检查插件类是否已注册
        if plugin_name not in self.plugin_classes:
            self.logger.error(f"插件类未注册: {plugin_name}")
            return None
        
        # 获取插件配置
        plugin_config = self.config_manager.get_plugin_config(plugin_name)
        
        # 检查插件是否启用
        if not plugin_config.get("enabled", True):
            self.logger.info(f"插件已禁用: {plugin_name}")
            return None
        
        try:
            # 创建插件实例
            plugin_class = self.plugin_classes[plugin_name]
            plugin = plugin_class(plugin_config)
            
            # 初始化插件
            if plugin.initialize():
                self.plugins[plugin_name] = plugin
                self.logger.info(f"插件已加载: {plugin_name}")
                return plugin
            else:
                self.logger.error(f"插件初始化失败: {plugin_name}")
                return None
        except Exception as e:
            self.logger.error(f"加载插件异常: {plugin_name} - {str(e)}", exc_info=True)
            return None
    
    def get_plugin(self, plugin_name):
        """获取插件实例，如果尚未加载则加载插件"""
        # 检查插件是否启用
        if not self.enabled:
            return None
        
        # 尝试获取已加载的插件
        if plugin_name in self.plugins:
            return self.plugins[plugin_name]
        
        # 加载插件
        return self.load_plugin(plugin_name)
    
    def unload_plugin(self, plugin_name):
        """卸载插件"""
        if plugin_name in self.plugins:
            # 调用清理方法
            try:
                self.plugins[plugin_name].cleanup()
            except Exception as e:
                self.logger.error(f"插件清理异常: {plugin_name} - {str(e)}")
            
            # 移除插件
            del self.plugins[plugin_name]
            self.logger.info(f"插件已卸载: {plugin_name}")
            return True
        
        return False
    
    def get_all_plugin_classes(self):
        """获取所有已注册的插件类"""
        return {name: cls.get_plugin_info() for name, cls in self.plugin_classes.items()}
    
    def get_loaded_plugins(self):
        """获取所有已加载的插件"""
        return self.plugins.copy()
    
    def shutdown(self):
        """关闭插件管理器，卸载所有插件"""
        for plugin_name in list(self.plugins.keys()):
            self.unload_plugin(plugin_name)
        
        self.logger.info("所有插件已卸载")
```

### 7.3 实现插件

以Web指纹识别插件为例，说明如何实现一个具体的插件：

```python
class FingerprintScanner(BasePlugin):
    """Web应用指纹识别插件
    
    用于识别Web服务器、框架、CMS等技术栈。
    """
    
    VERSION = "1.0.0"
    AUTHOR = "NetTools Team"
    REQUIRES = ["requests>=2.25.0", "beautifulsoup4>=4.9.0"]
    
    def initialize(self) -> bool:
        """初始化插件"""
        # 检查配置
        if not self.config:
            self.logger.error("插件配置缺失")
            return False
        
        # 验证patterns是否存在
        if "patterns" not in self.config:
            self.logger.error("指纹模式配置缺失")
            return False
        
        # 设置默认值
        settings = self.config.get("settings", {})
        self.timeout = settings.get("timeout", 10)
        self.user_agent = settings.get("user_agent", "Mozilla/5.0 ...")
        self.verify_ssl = settings.get("verify_ssl", True)
        self.follow_redirects = settings.get("follow_redirects", True)
        
        # 加载指纹模式
        self.patterns = self.config.get("patterns", [])
        self.logger.info(f"已加载 {len(self.patterns)} 个指纹模式")
        
        # 初始化请求会话
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': self.user_agent
        })
        
        return True
    
    def execute(self, url: str, **kwargs) -> Dict[str, Any]:
        """执行指纹识别
        
        Args:
            url: 目标URL
            **kwargs: 可选参数
        
        Returns:
            Dict: 识别结果
        """
        # 验证URL
        if not url:
            return {
                "success": False,
                "error": "URL不能为空"
            }
        
        # 标准化URL
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
        
        # 提取域名
        domain = urlparse(url).netloc
        
        # 获取参数
        timeout = kwargs.get("timeout", self.timeout)
        verify_ssl = kwargs.get("verify_ssl", self.verify_ssl)
        
        # 初始化结果
        result = {
            "url": url,
            "domain": domain,
            "technologies": [],
            "headers": {},
            "success": True
        }
        
        try:
            # 请求根路径
            response = self.session.get(
                url, 
                timeout=timeout,
                verify=verify_ssl,
                allow_redirects=self.follow_redirects
            )
            
            # 保存响应头
            result["headers"] = dict(response.headers)
            
            # 提取服务器信息
            if 'Server' in response.headers:
                result["server"] = response.headers['Server']
            
            # 检查所有模式
            for pattern in self.patterns:
                if self._check_pattern(response, pattern, url):
                    result["technologies"].append(pattern["name"])
            
            return result
        
        except requests.RequestException as e:
            self.logger.error(f"请求异常: {url} - {str(e)}")
            return {
                "url": url,
                "domain": domain,
                "success": False,
                "error": str(e)
            }
    
    def _check_pattern(self, response, pattern, base_url):
        """检查指纹模式是否匹配"""
        # 检查特定路径
        if "path" in pattern:
            path_url = urljoin(base_url, pattern["path"])
            try:
                path_response = self.session.get(
                    path_url,
                    timeout=self.timeout,
                    verify=self.verify_ssl,
                    allow_redirects=self.follow_redirects
                )
                
                # 检查内容
                if "content" in pattern and pattern["content"] in path_response.text:
                    return True
                
                # 检查头部
                if "headers" in pattern:
                    for header_name, header_value in pattern["headers"].items():
                        if header_name in path_response.headers and \
                           header_value in path_response.headers[header_name]:
                            return True
            except:
                pass
        
        # 检查响应内容
        if "content" in pattern and pattern["content"] in response.text:
            return True
        
        # 检查响应头
        if "headers" in pattern:
            for header_name, header_value in pattern["headers"].items():
                if header_name in response.headers and \
                   header_value in response.headers[header_name]:
                    return True
        
        return False
    
    def cleanup(self) -> None:
        """清理资源"""
        if hasattr(self, 'session'):
            self.session.close()
```

### 7.4 使用插件

在其他模块中使用插件的示例：

```python
# 获取插件管理器实例
plugin_manager = PluginManager()

# 加载并使用指纹识别插件
fingerprint_plugin = plugin_manager.get_plugin("FingerprintScanner")
if fingerprint_plugin:
    result = fingerprint_plugin.execute("https://example.com")
    print(f"检测到的技术栈: {result['technologies']}")
else:
    print("指纹识别插件未加载")
```

### 7.5 插件开发指南

#### 7.5.1 创建新插件

1. 在 `plugins/` 目录下创建一个新的Python文件或子目录
2. 定义一个继承自 `BasePlugin` 的插件类
3. 实现 `initialize()` 和 `execute()` 方法
4. (可选) 在 `configs/plugins/` 目录下创建配置文件

#### 7.5.2 插件开发规范

1. **接口定义清晰**：`execute()` 方法的参数和返回值应有明确的定义
2. **错误处理**：妥善处理各种异常，避免插件错误影响主程序
3. **资源释放**：在 `cleanup()` 方法中释放所有资源
4. **信息提供**：通过类属性 (VERSION, AUTHOR, REQUIRES) 和文档字符串提供插件信息
5. **配置验证**：在 `initialize()` 中验证配置的有效性
6. **日志记录**：使用 `self.logger` 记录关键操作和错误

## 8. 工具与辅助模块

工具与辅助模块提供了一系列通用功能，供其他模块使用，避免代码重复并确保一致性。

### 8.1 网络工具 (utils/network.py)

网络工具模块封装了常用的网络操作，如IP地址处理、HTTP请求等。

```python
"""网络工具模块
提供网络操作相关的工具函数
"""

import socket
import ipaddress
import requests
import netifaces
from typing import List, Dict, Any, Optional, Tuple

def is_valid_ip(ip: str) -> bool:
    """
    验证IP地址格式是否有效
    
    Args:
        ip: 待验证的IP地址字符串
        
    Returns:
        bool: 是否为有效IP地址
    """
    try:
        ipaddress.ip_address(ip)
        return True
    except ValueError:
        return False

def is_valid_network(network: str) -> bool:
    """
    验证网络地址（CIDR格式）是否有效
    
    Args:
        network: 待验证的网络地址，如192.168.1.0/24
        
    Returns:
        bool: 是否为有效网络地址
    """
    try:
        ipaddress.ip_network(network)
        return True
    except ValueError:
        return False

def expand_ip_range(ip_range: str) -> List[str]:
    """
    展开IP范围为IP地址列表
    
    支持以下格式:
    - 单个IP: 192.168.1.1
    - CIDR格式: 192.168.1.0/24
    - 范围格式: 192.168.1.1-192.168.1.10
    - 通配符格式: 192.168.1.*
    
    Args:
        ip_range: IP范围字符串
        
    Returns:
        List[str]: IP地址列表
    """
    # 实现IP范围展开逻辑
    # ...

def get_mac_address(ip: str) -> Optional[str]:
    """
    获取指定IP地址的MAC地址
    
    Args:
        ip: 目标IP地址
        
    Returns:
        Optional[str]: MAC地址或None
    """
    # 实现MAC地址获取逻辑
    # ...

def get_hostname(ip: str) -> str:
    """
    尝试获取IP地址的主机名
    
    Args:
        ip: 目标IP地址
        
    Returns:
        str: 主机名或原始IP
    """
    try:
        return socket.gethostbyaddr(ip)[0]
    except (socket.herror, socket.gaierror):
        return ip

def get_local_interfaces() -> List[Dict[str, Any]]:
    """
    获取本地网络接口信息
    
    Returns:
        List[Dict]: 接口信息列表
    """
    interfaces = []
    
    for interface in netifaces.interfaces():
        addrs = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addrs:
            for addr in addrs[netifaces.AF_INET]:
                ip = addr.get('addr')
                if ip and ip != '127.0.0.1':
                    interfaces.append({
                        'name': interface,
                        'ip': ip,
                        'netmask': addr.get('netmask'),
                        'broadcast': addr.get('broadcast')
                    })
    
    return interfaces

def http_request(url: str, method: str = 'GET', **kwargs) -> Tuple[int, Dict, str]:
    """
    执行HTTP请求
    
    Args:
        url: 请求URL
        method: 请求方法
        **kwargs: 其他请求参数
        
    Returns:
        Tuple[int, Dict, str]: (状态码, 响应头, 响应内容)
    """
    try:
        response = requests.request(method, url, **kwargs)
        return response.status_code, dict(response.headers), response.text
    except requests.RequestException as e:
        return 0, {}, str(e)
```

### 8.2 导出工具 (utils/export.py)

导出工具模块用于将扫描结果导出为不同格式的文件。

```python
"""导出工具模块
提供将扫描结果导出为不同格式的功能
"""

import csv
import json
import os
from typing import List, Dict, Any, Optional
import pandas as pd

class ExportUtility:
    """导出工具类"""
    
    @staticmethod
    def export_to_csv(data: List[Dict[str, Any]], filename: str) -> bool:
        """
        导出数据到CSV文件
        
        Args:
            data: 数据列表，每项为一个字典
            filename: 输出文件名
            
        Returns:
            bool: 是否成功
        """
        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            
            # 获取所有字段
            if not data:
                return False
            
            fields = set()
            for item in data:
                fields.update(item.keys())
            
            # 写入CSV
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=list(fields))
                writer.writeheader()
                writer.writerows(data)
            
            return True
        except Exception as e:
            print(f"CSV导出失败: {str(e)}")
            return False
    
    @staticmethod
    def export_to_json(data: Any, filename: str) -> bool:
        """
        导出数据到JSON文件
        
        Args:
            data: 要导出的数据
            filename: 输出文件名
            
        Returns:
            bool: 是否成功
        """
        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            
            # 写入JSON
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            return True
        except Exception as e:
            print(f"JSON导出失败: {str(e)}")
            return False
    
    @staticmethod
    def export_to_excel(data: List[Dict[str, Any]], filename: str, sheet_name: str = 'Sheet1') -> bool:
        """
        导出数据到Excel文件
        
        Args:
            data: 数据列表，每项为一个字典
            filename: 输出文件名
            sheet_name: 工作表名称
            
        Returns:
            bool: 是否成功
        """
        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            
            # 转换为DataFrame
            df = pd.DataFrame(data)
            
            # 写入Excel
            with pd.ExcelWriter(filename) as writer:
                df.to_excel(writer, sheet_name=sheet_name, index=False)
            
            return True
        except Exception as e:
            print(f"Excel导出失败: {str(e)}")
            return False
    
    @staticmethod
    def format_scan_result_for_export(result: 'ScanResult') -> Dict[str, Any]:
        """
        格式化扫描结果用于导出
        
        Args:
            result: 扫描结果对象
            
        Returns:
            Dict: 格式化后的结果
        """
        # 转换为字典
        result_dict = result.to_dict()
        
        # 添加更多元信息
        result_dict['formatted_start_time'] = pd.to_datetime(result_dict['start_time']).strftime('%Y-%m-%d %H:%M:%S')
        result_dict['formatted_end_time'] = pd.to_datetime(result_dict['end_time']).strftime('%Y-%m-%d %H:%M:%S')
        result_dict['formatted_duration'] = f"{result_dict['duration']:.2f}秒"
        
        return result_dict
```

## 9. 数据可视化

NetTools提供了多种数据可视化方式，特别是网络拓扑图、统计图表和实时监控视图。主要使用NetworkX、Matplotlib和PyQt5的绘图能力。

### 9.1 网络拓扑图

网络拓扑图是NetTools的核心可视化功能之一，使用NetworkX库生成网络图，并通过Matplotlib或PyQt5显示。

#### 9.1.1 NetworkX集成

`gui/host_topology_networkx.py` 和 `gui/port_topology_networkx.py` 实现了网络拓扑图的生成和显示。

**主机拓扑图核心实现**:

```python
class HostTopologyView(QWidget):
    """主机拓扑图视图"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.graph = nx.Graph()
        
        # 创建Matplotlib画布
        self.figure = plt.figure(figsize=(8, 6))
        self.canvas = FigureCanvas(self.figure)
        
        # 创建导航工具栏
        self.toolbar = NavigationToolbar(self.canvas, self)
        
        # 创建控制面板
        self.controls = self._create_controls()
        
        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        layout.addWidget(self.controls)
        self.setLayout(layout)
        
        # 初始化图
        self.clear_graph()
    
    def _create_controls(self):
        """创建控制面板"""
        group_box = QGroupBox("拓扑图设置")
        layout = QHBoxLayout()
        
        # 布局算法选择
        layout.addWidget(QLabel("布局算法:"))
        self.layout_combo = QComboBox()
        self.layout_combo.addItems([
            "弹簧布局", "圆形布局", "同心圆布局", "Kamada-Kawai布局"
        ])
        self.layout_combo.currentIndexChanged.connect(self.redraw_graph)
        layout.addWidget(self.layout_combo)
        
        # 节点大小
        layout.addWidget(QLabel("节点大小:"))
        self.node_size_spin = QSpinBox()
        self.node_size_spin.setRange(100, 1000)
        self.node_size_spin.setValue(500)
        self.node_size_spin.setSingleStep(50)
        self.node_size_spin.valueChanged.connect(self.redraw_graph)
        layout.addWidget(self.node_size_spin)
        
        # 刷新按钮
        self.refresh_btn = QPushButton("刷新")
        self.refresh_btn.clicked.connect(self.redraw_graph)
        layout.addWidget(self.refresh_btn)
        
        group_box.setLayout(layout)
        return group_box
    
    def clear_graph(self):
        """清空图"""
        self.graph = nx.Graph()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        ax.text(0.5, 0.5, "无拓扑数据", ha='center', va='center')
        ax.axis('off')
        self.canvas.draw()
    
    def update_graph(self, hosts_data):
        """更新图数据"""
        # 创建新图
        self.graph = nx.Graph()
        
        # 网关和本机标识
        gateway_ip = None
        local_ip = None
        
        # 查找可能的网关
        for host in hosts_data:
            if host.get('is_gateway', False):
                gateway_ip = host['ip']
            if host.get('is_local', False):
                local_ip = host['ip']
        
        # 添加节点
        for host in hosts_data:
            ip = host['ip']
            self.graph.add_node(ip)
            
            # 设置节点属性
            node_attrs = {
                'label': host.get('hostname', ip),
                'type': 'gateway' if ip == gateway_ip else 'local' if ip == local_ip else 'host',
                'mac': host.get('mac', ''),
                'status': host.get('status', ''),
                'response_time': host.get('response_time', 0)
            }
            nx.set_node_attributes(self.graph, {ip: node_attrs})
        
        # 如果找到网关，以它为中心添加连接
        if gateway_ip:
            for node in self.graph.nodes():
                if node != gateway_ip:
                    self.graph.add_edge(gateway_ip, node)
        
        # 否则根据网络前缀推断连接
        else:
            nodes = list(self.graph.nodes())
            for i in range(len(nodes)):
                for j in range(i+1, len(nodes)):
                    # 简单判断：前3段相同则连接
                    ip1_parts = nodes[i].split('.')
                    ip2_parts = nodes[j].split('.')
                    if ip1_parts[:3] == ip2_parts[:3]:
                        self.graph.add_edge(nodes[i], nodes[j])
        
        # 绘制图
        self.redraw_graph()
    
    def redraw_graph(self):
        """重绘图"""
        # 清空图
        self.figure.clear()
        
        # 如果没有节点，显示提示文本
        if not self.graph.nodes():
            ax = self.figure.add_subplot(111)
            ax.text(0.5, 0.5, "无拓扑数据", ha='center', va='center')
            ax.axis('off')
            self.canvas.draw()
            return
        
        # 选择布局算法
        layout_idx = self.layout_combo.currentIndex()
        if layout_idx == 0:  # 弹簧布局
            pos = nx.spring_layout(self.graph)
        elif layout_idx == 1:  # 圆形布局
            pos = nx.circular_layout(self.graph)
        elif layout_idx == 2:  # 同心圆布局
            pos = nx.shell_layout(self.graph)
        elif layout_idx == 3:  # Kamada-Kawai布局
            pos = nx.kamada_kawai_layout(self.graph)
        
        # 获取节点大小
        node_size = self.node_size_spin.value()
        
        # 为不同类型的节点设置不同颜色
        node_colors = []
        for node in self.graph.nodes():
            node_type = self.graph.nodes[node].get('type', 'host')
            if node_type == 'gateway':
                node_colors.append('red')
            elif node_type == 'local':
                node_colors.append('green')
            else:
                node_colors.append('skyblue')
        
        # 绘制图
        ax = self.figure.add_subplot(111)
        nx.draw(
            self.graph, pos, 
            with_labels=True, 
            node_color=node_colors,
            node_size=node_size,
            font_size=10,
            ax=ax
        )
        
        # 更新画布
        self.canvas.draw()
```

#### 9.1.2 端口拓扑图

端口拓扑图用于可视化目标主机的端口状态和服务识别结果：

```python
class PortTopologyView(QWidget):
    """端口拓扑图视图"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # 实现类似于HostTopologyView，但针对端口数据
        # ...
```

### 9.2 统计图表

除了网络拓扑图，NetTools还提供了各种统计图表，用于展示如扫描结果分布、响应时间等数据。

#### 9.2.1 Ping监控图表

```python
class PingStatisticsChart(QWidget):
    """Ping统计图表"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 创建Matplotlib画布
        self.figure = plt.figure(figsize=(8, 4))
        self.canvas = FigureCanvas(self.figure)
        
        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.canvas)
        self.setLayout(layout)
        
        # 数据
        self.timestamps = []
        self.response_times = []
        self.packet_loss = []
        
        # 初始化图表
        self.init_chart()
    
    def init_chart(self):
        """初始化图表"""
        self.figure.clear()
        
        # 创建子图
        self.ax1 = self.figure.add_subplot(211)  # 响应时间图
        self.ax2 = self.figure.add_subplot(212)  # 丢包率图
        
        # 设置标题和标签
        self.ax1.set_title('Ping响应时间')
        self.ax1.set_ylabel('响应时间 (ms)')
        self.ax1.set_xlabel('时间')
        
        self.ax2.set_title('丢包率')
        self.ax2.set_ylabel('丢包率 (%)')
        self.ax2.set_xlabel('时间')
        self.ax2.set_ylim(0, 100)
        
        # 初始线条
        self.line1, = self.ax1.plot([], [], 'b-')
        self.line2, = self.ax2.plot([], [], 'r-')
        
        self.figure.tight_layout()
        self.canvas.draw()
    
    def update_chart(self, ping_data):
        """更新图表数据"""
        # 提取数据
        self.timestamps.append(ping_data['timestamp'])
        
        if ping_data['success']:
            self.response_times.append(ping_data['response_time'])
            self.packet_loss.append(0)
        else:
            self.response_times.append(None)
            self.packet_loss.append(100)
        
        # 保持最近100个数据点
        max_points = 100
        if len(self.timestamps) > max_points:
            self.timestamps = self.timestamps[-max_points:]
            self.response_times = self.response_times[-max_points:]
            self.packet_loss = self.packet_loss[-max_points:]
        
        # 更新图表
        self.redraw_chart()
class TestScannerIntegration(unittest.TestCase):
    def test_full_scan_workflow(self):
        pass
```

## 10. 开发指南

### 10.1 代码风格规范

#### 10.1.1 Python 代码规范

NetTools 项目遵循 PEP 8 规范，同时增加了以下项目特定规则：

1. **导入顺序**：

   ```python
   # 标准库导入
   import os
   import sys
   
   # 第三方库导入
   import numpy as np
   import pandas as pd
   
   # 项目内模块导入
   from core.base_scanner import BaseScanner
   from utils.network import is_valid_ip
   ```

2. **文档字符串**：所有模块、类和公共方法必须有文档字符串，采用以下格式：

   ```python
   def function_name(arg1, arg2):
       """简短的功能描述（一行）
       
       详细的功能描述（可多行）
       
       Args:
           arg1: 参数1的描述
           arg2: 参数2的描述
           
       Returns:
           返回值描述
           
       Raises:
           可能抛出的异常
       """
   ```

3. **命名约定**：

   - 类名：采用 `CamelCase`
   - 方法/函数：采用 `snake_case`
   - 常量：采用 `ALL_CAPS`
   - 私有方法/属性：以单下划线开头，如 `_private_method`

4. **行长度**：每行代码不超过 100 字符

5. **注释**：

   - 代码逻辑应自解释，避免不必要的注释
   - 复杂算法或非显而易见的实现需要添加注释
   - 注释应解释"为什么"而不是"做了什么"

#### 10.1.2 GUI 设计规范

1. **布局一致性**：
   - 所有面板采用统一的布局结构：参数区域、操作按钮、结果显示
   - 控件间距保持一致（水平 10px，垂直 8px）

2. **命名约定**：
   - 控件变量名应反映其类型和用途，如 `ip_range_input`、`start_scan_button`

3. **事件处理**：
   - 将 UI 事件处理与业务逻辑分离
   - 长时间操作应使用线程，避免阻塞 UI

4. **响应式设计**：
   - 面板应适应窗口大小变化
   - 使用 QSplitter 允许用户调整区域大小

### 10.2 开发流程

#### 10.2.1 功能开发流程

1. **需求分析**：明确功能需求和设计目标
2. **模块设计**：设计模块接口和内部结构
3. **编码实现**：按照规范编写代码
4. **单元测试**：为新功能编写单元测试
5. **集成测试**：验证与现有模块的集成
6. **代码审查**：由团队成员审查代码
7. **文档更新**：更新相关文档
8. **最终测试**：在各目标平台上测试

#### 10.2.2 版本控制流程

1. **分支管理**：

   - `master`：稳定发布版本
   - `develop`：开发主分支
   - `feature/*`：新功能开发
   - `bugfix/*`：Bug 修复
   - `release/*`：发布准备

2. **提交规范**：

   ```
   [类型]: 简短描述（不超过50个字符）
   
   详细描述（可选，每行不超过72个字符）
   
   相关 issue: #123
   ```

   类型包括：

   - `feat`: 新功能
   - `fix`: Bug 修复
   - `docs`: 文档更新
   - `style`: 代码风格调整（不影响功能）
   - `refactor`: 代码重构
   - `test`: 测试相关
   - `chore`: 构建过程或辅助工具变动

### 10.3 扩展指南

#### 10.3.1 添加新扫描模块

1. **创建扫描器类**：

   ```python
   # core/new_scanner.py
   from core.base_scanner import BaseScanner, ScanResult
   
   class NewScanner(BaseScanner):
       """新扫描器描述"""
       
       VERSION = "1.0.0"
       
       def validate_config(self):
           """验证配置"""
           # 实现配置验证
           return True, None
       
       def run_scan(self):
           """执行扫描"""
           # 实现扫描逻辑
           return ScanResult(success=True, data=[])
   ```

2. **创建 GUI 面板**：

   ```python
   # gui/panels/new_scanner_panel.py
   from gui.panels.base_panel import BasePanel
   
   class NewScannerPanel(BasePanel):
       """新扫描器界面"""
       
       MODULE_ID = "newscanner"
       MODULE_NAME = "新扫描器"
       
       def create_param_group(self):
           """创建参数组"""
           # 实现参数控件
           
       def get_scan_config(self):
           """获取扫描配置"""
           # 从 UI 控件获取配置
           
       def display_results(self, result):
           """显示结果"""
           # 实现结果展示
   ```

3. **注册到主界面**：
   在 `gui/main.py` 的 `load_modules` 方法中添加：

   ```python
   # 添加新扫描面板
   new_panel = NewScannerPanel()
   self.tab_widget.addTab(new_panel, "新扫描器")
   ```

4. **添加命令行支持**：
   在 `cli/main.py` 中添加相应参数和处理逻辑

#### 10.3.2 创建新插件

1. **实现插件类**：

   ```python
   # plugins/custom/new_plugin.py
   from plugins.base_plugin import BasePlugin
   
   class NewPlugin(BasePlugin):
       """新插件描述"""
       
       VERSION = "1.0.0"
       AUTHOR = "作者名"
       REQUIRES = ["依赖库"]
       
       def initialize(self):
           """初始化插件"""
           # 验证配置
           # 加载资源
           return True
       
       def execute(self, *args, **kwargs):
           """执行插件功能"""
           # 实现插件逻辑
           return {"success": True, "data": {}}
       
       def cleanup(self):
           """清理资源"""
           # 释放资源
   ```

2. **创建插件配置**：

   ```json
   // configs/plugins/newplugin.json
   {
       "name": "NewPlugin",
       "enabled": true,
       "version": "1.0.0",
       "description": "新插件描述",
       "settings": {
           "option1": "value1",
           "option2": "value2"
       }
   }
   ```

## 11. 测试规范

### 11.1 测试框架

NetTools 项目采用 pytest 作为测试框架，所有测试代码位于 `tests/` 目录下。

```
tests/
├── unit/              # 单元测试
│   ├── core/          # 核心模块测试
│   ├── utils/         # 工具函数测试
│   └── plugins/       # 插件测试
├── integration/       # 集成测试
├── functional/        # 功能测试
├── conftest.py        # 测试配置
└── __init__.py
```

### 11.2 单元测试

单元测试用于验证各个模块和函数的独立功能，遵循以下规则：

1. **测试命名**：

   - 测试文件命名为 `test_模块名.py`
   - 测试函数命名为 `test_功能名`

2. **测试覆盖**：

   - 每个公共方法至少有一个测试
   - 应测试正常情况和边界条件
   - 使用 mock 对象隔离外部依赖

3. **测试示例**：

   ```python
   # tests/unit/core/test_host_scanner.py
   import pytest
   from unittest.mock import patch
   from core.host_scan import HostScanner
   
   def test_validate_config_valid_input():
       # 准备
       scanner = HostScanner({"ip_range": "192.168.1.0/24"})
       
       # 执行
       is_valid, error = scanner.validate_config()
       
       # 验证
       assert is_valid
       assert error is None
   
   def test_validate_config_invalid_input():
       # 准备
       scanner = HostScanner({})
       
       # 执行
       is_valid, error = scanner.validate_config()
       
       # 验证
       assert not is_valid
       assert "ip_range" in error
   
   @patch('core.host_scan.ping')
   def test_icmp_scan(mock_ping):
       # 设置 mock
       mock_ping.return_value = (True, 10.5)
       
       # 准备
       scanner = HostScanner({
           "ip_range": "192.168.1.1",
           "method": "icmp"
       })
       
       # 执行
       result = scanner.run_scan()
       
       # 验证
       assert result.success
       assert len(result.data) == 1
       assert result.data[0]["ip"] == "192.168.1.1"
       assert result.data[0]["status"] == "up"
   ```

### 11.3 集成测试

集成测试验证模块之间的交互，主要关注：

1. **扫描器与配置管理的集成**
2. **扫描器与插件系统的集成**
3. **CLI 与核心模块的集成**
4. **GUI 与核心模块的集成**

```python
# tests/integration/test_scanner_integration.py
import pytest
from core.scanner_manager import scanner_manager
from utils.config import config_manager

class TestScannerIntegration:
    def test_scanner_with_config(self):
        # 准备
        config = config_manager.get_module_config("hostscanner")
        config["ip_range"] = "127.0.0.1"
        
        # 执行
        scanner = scanner_manager.create_scanner("HostScanner", config)
        result = scanner.execute()
        
        # 验证
        assert result.success
        assert len(result.data) == 1
        assert result.data[0]["ip"] == "127.0.0.1"
```

### 11.4 自动化测试

项目使用 GitHub Actions 进行自动化测试，配置文件位于 `.github/workflows/tests.yml`：

```yaml
name: Tests

on:
  push:
    branches: [master, develop]
  pull_request:
    branches: [master, develop]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: [3.8, 3.9]

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov
        pip install -r requirements.txt
    - name: Test with pytest
      run: |
        pytest tests/ --cov=./ --cov-report=xml
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
```

## 12. 常见问题与解决方案

### 12.1 安装问题

#### 12.1.1 依赖冲突

**问题**：安装时出现包依赖冲突。

**解决方案**：

1. 使用虚拟环境隔离依赖
2. 安装时使用 `--no-deps` 跳过依赖安装，然后手动安装需要的版本
3. 检查 `requirements.txt` 是否指定了兼容的版本范围

#### 12.1.2 平台特定依赖安装失败

**问题**：在特定平台上某些依赖安装失败。

**解决方案**：

1. Windows 平台：
   - 对于编译类错误，安装 Visual C++ Build Tools
   - 使用预编译的二进制包：`pip install 包名 --only-binary :all:`

2. Linux 平台：
   - 安装开发库：`sudo apt-get install python3-dev libpcap-dev`
   - 对于 Scapy，确保安装了 libpcap-dev

### 12.2 运行问题

#### 12.2.1 权限不足

**问题**：执行扫描时权限不足。

**解决方案**：

1. Windows：以管理员身份运行
2. Linux/macOS：
   - 使用 sudo 运行
   - 或设置 capabilities：`sudo setcap cap_net_raw+ep $(which python3)`

#### 12.2.2 扫描速度慢

**问题**：扫描执行速度较慢。

**解决方案**：

1. 增加线程数：修改配置中的 `max_threads` 参数
2. 优化扫描范围：减少目标主机数或端口范围
3. 调整超时参数：减小 `timeout` 值，但可能增加误报
4. 使用更高效的扫描方法：例如主机扫描选择 ARP 而非 ICMP

### 12.3 开发问题

#### 12.3.1 GUI 线程安全

**问题**：GUI 中更新界面时出现线程安全问题。

**解决方案**：

1. 使用 Qt 信号-槽机制进行线程间通信
2. 不在工作线程中直接操作 UI 元素
3. 使用 `QMetaObject.invokeMethod` 进行线程安全的方法调用

```python
# 正确的方式
class ScanThread(QThread):
    update_signal = pyqtSignal(str)
    
    def run(self):
        # 计算结果
        result = "计算结果"
        # 发送信号
        self.update_signal.emit(result)

# 主线程中连接信号
thread.update_signal.connect(self.update_ui)
```

#### 12.3.2 插件加载失败

**问题**：插件无法正确加载。

**解决方案**：

1. 检查插件路径是否正确
2. 验证插件类是否正确继承了 BasePlugin
3. 查看日志文件中的详细错误信息
4. 确保插件的依赖已安装

### 12.4 功能问题

#### 12.4.1 扫描结果不准确

**问题**：扫描结果不准确或漏报。

**解决方案**：

1. 调整扫描参数：增加重试次数、调整超时时间
2. 检查网络环境：是否有防火墙或IPS系统干扰
3. 尝试不同的扫描方法：某些环境下特定扫描方法效果更好

#### 12.4.2 高资源占用

**问题**：运行时占用过多系统资源。

**解决方案**：

1. 降低并行线程数
2. 增加扫描延迟（scan_delay 参数）
3. 分批执行大规模扫描
4. 优化内存使用：及时释放不需要的资源

## 12. 常见问题与解决方案

## 13. 维护指南 

### 13.1 版本发布流程

1. **准备发布**：
   - 确认所有测试通过
   - 更新版本号（`setup.py` 和文档）
   - 更新 CHANGELOG.md

2. **创建发布分支**：
   ```bash
   git checkout develop
   git checkout -b release/v1.x.x
   ```

3. **最终测试**：
   - 在所有目标平台执行测试
   - 修复发现的问题

4. **完成发布**：
   ```bash
   git checkout master
   git merge release/v1.x.x
   git tag -a v1.x.x -m "版本 1.x.x"
   git push origin master --tags
   ```

5. **更新开发分支**：
   ```bash
   git checkout develop
   git merge master
   git push origin develop
   ```

### 13.2 日志分析

系统日志位于 `logs/` 目录，包括以下文件：
- `nettools.log`：主应用日志
- `scanner.log`：扫描模块日志
- `gui.log`：图形界面日志
- `cli.log`：命令行界面日志
- `plugin.log`：插件系统日志

日志分析工具和方法：
1. **日志级别**：ERROR > WARNING > INFO > DEBUG
2. **常见错误模式**：
   - 网络连接问题：检查防火墙设置
   - 权限不足：使用管理员/root权限运行
   - 资源不足：检查系统资源占用情况

### 13.3 性能优化

#### 13.3.1 内存优化

1. **减少内存泄漏**：
   - 确保释放大型对象
   - 定期监控内存使用

2. **批处理大数据**：
   - 分批加载和处理结果数据
   - 避免一次性加载大量数据到内存

#### 13.3.2 速度优化

1. **优化扫描算法**：
   - 使用更高效的扫描技术
   - 优化目标选择和排序

2. **并行处理**：
   - 适当增加线程数
   - 使用进程池处理CPU密集型任务

3. **减少网络延迟**：
   - 批量发送请求
   - 使用异步I/O处理网络操作

### 13.4 插件管理

#### 13.4.1 更新插件

1. **获取插件更新**：
   - 从官方仓库拉取更新
   - 下载最新版本插件

2. **更新插件配置**：
   - 检查新版本配置要求
   - 更新 `configs/plugins/` 目录下的配置文件

#### 13.4.2 插件验证

1. **安全检查**：
   - 检查插件来源是否可信
   - 审查插件代码是否有安全隐患

2. **功能测试**：
   - 验证插件功能是否正常
   - 测试与其他组件的兼容性

### 13.5 备份与恢复

1. **备份项目**：
   ```bash
   # 备份配置和结果
   tar -czvf nettools_backup.tar.gz config/ configs/ results/
   ```

2. **备份数据库**：
   如果项目使用了数据库，确保定期备份数据库内容。

3. **恢复配置**：
   ```bash
   # 恢复配置文件
   tar -xzvf nettools_backup.tar.gz -C /path/to/nettools/
   ```

### 13.6 故障排除流程

1. **确认问题**：
   - 收集明确的错误信息和日志
   - 确定问题的复现步骤

2. **分析原因**：
   - 检查日志文件中的错误信息
   - 检查网络连接和系统资源
   - 审查相关代码

3. **解决问题**：
   - 应用临时修复
   - 开发永久解决方案
   - 更新文档记录问题和解决方法

4. **验证修复**：
   - 测试问题是否已解决
   - 确保修复没有引入新问题

5. **预防措施**：
   - 更新测试用例
   - 改进错误处理
   - 加强监控和预警
