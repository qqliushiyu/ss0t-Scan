# NetTools 网络扫描工具箱开发手册

## 目录

1. [项目概述](#1-项目概述)
2. [环境搭建](#2-环境搭建)
3. [项目结构](#3-项目结构)
4. [核心模块](#4-核心模块)
5. [用户界面](#5-用户界面)
6. [配置管理](#6-配置管理)
7. [插件系统](#7-插件系统)
8. [工具与辅助模块](#8-工具与辅助模块)
9. [数据可视化](#9-数据可视化)
10. [开发指南](#10-开发指南)
11. [测试规范](#11-测试规范)
12. [常见问题与解决方案](#12-常见问题与解决方案)
13. [维护指南](#13-维护指南)

## 1. 项目概述

### 1.1 项目简介

NetTools 是一个功能强大的多模块网络扫描工具集合，提供命令行和图形界面两种操作方式。本工具设计用于网络安全分析、网络拓扑探测和漏洞扫描等任务，采用模块化设计架构，使得功能扩展和维护变得简单高效。

NetTools 主要面向网络管理员、安全工程师和网络开发人员，可以帮助他们快速获取网络信息、检测安全隐患和分析网络结构。

### 1.2 主要功能

- **主机扫描**：发现局域网或指定IP范围内的活跃主机
  - 支持ARP、ICMP、TCP多种探测方式
  - 自动识别主机MAC地址和操作系统类型
  - 生成网络拓扑图，直观显示主机间的连接关系

- **端口扫描**：检测主机开放端口和运行的服务
  - 支持TCP SYN、TCP Connect、UDP多种扫描方式
  - 自动识别常见服务和版本信息
  - 可配置扫描速度和超时参数

- **DNS检测**：域名解析和记录查询
  - 查询A、AAAA、MX、NS、CNAME等各类DNS记录
  - 子域名枚举功能
  - DNS服务器配置检测

- **路由追踪**：网络路径分析
  - 可视化显示数据包经过的路由节点
  - 支持ICMPv4、ICMPv6、UDP和TCP多种追踪方式
  - 提供每一跳的延迟统计

- **Ping监控**：网络连通性检测
  - 长期监控目标主机状态
  - 提供图形化的延迟统计和丢包率
  - 支持告警功能

- **Web目录扫描**：Web应用目录探测
  - 内置常见目录和文件字典
  - 支持自定义字典和排除规则
  - 自动识别重定向和错误页面

- **Web安全风险扫描**：Web应用安全检测
  - Web服务指纹识别
  - 常见安全漏洞检测（SQL注入、XSS等）
  - 安全响应头分析
  - WAF(Web应用防火墙)检测

### 1.3 技术特点

- **模块化设计**：每个功能模块独立封装，便于维护和扩展
  - 核心扫描逻辑与UI界面分离
  - 基于接口和抽象类的扩展机制
  - 一致的模块通信协议

- **双重界面**：CLI和GUI两种操作方式
  - 命令行工具支持脚本自动化
  - 图形界面提供直观的操作和结果展示
  - 两种界面共享核心业务逻辑

- **数据导出**：支持多种格式
  - CSV格式：便于电子表格软件处理
  - JSON格式：便于程序化处理
  - Excel格式：提供丰富的数据表现形式

- **配置管理**：灵活的配置系统
  - 全局配置：适用于所有模块的通用设置
  - 模块配置：针对特定模块的专用设置
  - 用户配置：保存用户偏好

- **插件扩展**：丰富的扩展能力
  - 插件API：统一的插件接口
  - 动态加载：运行时发现和加载插件
  - 配置驱动：通过配置文件控制插件行为

- **可视化**：直观的数据展示
  - NetworkX网络拓扑图：展示网络结构
  - 实时图表：展示性能和统计数据
  - 交互式操作：支持缩放、拖拽等交互

### 1.4 应用场景

- **网络资产管理**：快速发现和统计网络中的设备和服务
- **安全评估**：检测网络和Web应用中的安全隐患
- **网络排障**：分析网络连通性和路由问题
- **性能监控**：监控关键设备的网络性能指标
- **安全研究**：为安全研究人员提供丰富的网络工具集

## 2. 环境搭建

### 2.1 系统要求

- **Python环境**：
  - Python 3.8 或更高版本
  - pip 20.0 或更高版本
  
- **操作系统支持**：
  - Windows 10/11 x64
  - Ubuntu 20.04/22.04 LTS
  - macOS 11.0+（Big Sur及更高版本）
  
- **硬件建议**：
  - CPU：2核心或以上
  - 内存：4GB或以上（大规模扫描建议8GB以上）
  - 磁盘空间：500MB可用空间
  
- **网络权限**：
  - 部分功能（如ARP扫描、原始套接字操作）需要管理员/root权限
  - 防火墙配置可能需要调整

### 2.2 依赖包

项目核心依赖包及其用途：

```
# 网络功能
scapy>=2.4.5       # 网络数据包处理和构造
netifaces>=0.11.0  # 网络接口信息获取
ipaddress>=1.0.23  # IP地址和网络操作
dnspython>=2.1.0   # DNS查询和解析

# HTTP和Web
requests>=2.28.0   # HTTP请求
beautifulsoup4>=4.10.0  # HTML解析
aiohttp>=3.8.0     # 异步HTTP请求（可选）

# GUI
PyQt5>=5.15.0      # 图形界面框架

# 数据处理
pandas>=1.3.0      # 数据分析和处理
openpyxl>=3.0.7    # Excel文件读写

# 数据可视化
networkx>=2.8.0    # 网络图创建和分析
matplotlib>=3.5.0  # 数据绘图
scipy>=1.10.0      # 科学计算（网络布局算法）

# 工具和辅助
pyyaml>=6.0        # YAML配置文件解析
cryptography>=36.0.0  # 加密功能
tqdm>=4.62.0       # 进度条显示
```

#### 依赖分组

**基础依赖**（必需）：
```
PyQt5>=5.15.0
scapy>=2.4.5
netifaces>=0.11.0
requests>=2.28.0
pandas>=1.3.0
networkx>=2.8.0
pyyaml>=6.0
```

**扩展依赖**（特定功能需要）：
```
openpyxl>=3.0.7    # Excel导出
matplotlib>=3.5.0  # 可视化图表
beautifulsoup4>=4.10.0  # Web扫描
dnspython>=2.1.0   # DNS功能
scipy>=1.10.0      # 高级网络布局
```

### 2.3 安装步骤

#### 2.3.1 基础安装

1. 克隆代码库：
```bash
git clone <repository_url>
cd nettools
```

2. 创建虚拟环境：
```bash
# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
## Linux/macOS:
source venv/bin/activate
## Windows:
venv\Scripts\activate
```

3. 安装依赖：
```bash
# 使用setup.py（推荐）
python setup.py

# 或直接安装所有依赖
pip install -r requirements.txt
```

#### 2.3.2 操作系统特定设置

**Windows系统**：
1. 安装Npcap（Scapy的依赖）：
   - 下载: https://npcap.com/
   - 安装时选择"Install Npcap in WinPcap API-compatible Mode"

2. 管理员权限：
   - 部分功能需要以管理员身份运行命令提示符或PowerShell

**Linux系统**：
1. 安装依赖包：
```bash
# Ubuntu/Debian:
sudo apt-get update
sudo apt-get install -y python3-dev libpcap-dev
```

2. 配置权限：
```bash
# 允许非root用户使用ping
sudo sysctl -w net.ipv4.ping_group_range="0 2147483647"

# 或将应用程序设置为setcap
sudo setcap cap_net_raw+ep $(which python3)
```

**macOS系统**：
1. 安装依赖：
```bash
# 通过Homebrew安装
brew install libpcap
```

2. 权限设置：
   - 部分功能需要在终端中使用sudo运行

#### 2.3.3 开发环境设置

对于开发者，建议安装以下额外工具：

```bash
# 开发工具
pip install -r requirements-dev.txt

# 包含以下内容：
# pytest - 单元测试
# pylint - 代码检查
# autopep8 - 代码格式化
# sphinx - 文档生成
```

### 2.4 运行方式

#### 2.4.1 图形界面

启动图形用户界面（GUI）：
```bash
# 直接运行模块
python -m gui.main

# 或使用安装后的快捷命令（如果通过setup.py安装）
nettools-gui
```

#### 2.4.2 命令行界面

使用命令行界面（CLI）：
```bash
# 显示帮助
python -m cli.main --help

# 列出可用模块
python -m cli.main list

# 运行特定扫描模块
python -m cli.main run <module_name> [options]

# 例如，扫描主机
python -m cli.main run hostscanner --ip_range 192.168.1.0/24

# 或使用安装后的快捷命令
nettools-cli run hostscanner --ip_range 192.168.1.0/24
```

#### 2.4.3 配置管理

通过命令行管理配置：
```bash
# 查看当前配置
python -m cli.main config show

# 设置配置项
python -m cli.main config set scanning.max_threads 20

# 重置配置到默认值
python -m cli.main config reset
```

### 2.5 快速入门示例

#### 主机扫描示例

```bash
# CLI方式
python -m cli.main run hostscanner --ip_range 192.168.1.0/24 --method icmp

# 导出结果到CSV
python -m cli.main run hostscanner --ip_range 192.168.1.0/24 --output results/hosts.csv
```

#### 端口扫描示例

```bash
# 扫描单个主机的常用端口
python -m cli.main run portscanner --target 192.168.1.1 --ports common

# 扫描特定端口范围
python -m cli.main run portscanner --target 192.168.1.1 --ports 1-1000 --method syn
```

#### Web风险扫描示例

```bash
# 扫描网站安全性
python -m cli.main run webriskscanner --url https://example.com --check-headers --check-waf
```

## 3. 项目结构

### 3.1 目录结构总览

NetTools项目采用模块化设计，各个功能组件按照职责划分到不同目录中：

```
nettools/
├── cli/                    # 命令行界面
│   ├── main.py             # CLI入口
│   ├── config/             # CLI配置
│   └── logs/               # CLI日志
│
├── config/                 # 主配置目录
│   └── settings.ini        # 全局配置文件
│
├── configs/                # 扩展配置目录
│   ├── plugins/            # 插件配置文件
│   │   ├── fingerprintscanner.json  # Web指纹识别配置
│   │   ├── sqlinjectionscanner.json # SQL注入扫描配置
│   │   ├── wafdetector.json         # WAF检测配置
│   │   └── ...
│   └── fingerprints.txt    # Web指纹库
│
├── core/                   # 核心扫描逻辑
│   ├── base_scanner.py     # 扫描器基类
│   ├── scanner_manager.py  # 扫描器管理器
│   ├── host_scan.py        # 主机扫描实现
│   ├── port_scan.py        # 端口扫描实现
│   ├── dns_check.py        # DNS检测实现
│   ├── traceroute.py       # 路由追踪实现
│   ├── ping_monitor.py     # Ping监控实现
│   ├── tcp_ping.py         # TCP Ping实现
│   ├── web_dir_scan.py     # Web目录扫描实现
│   └── web_risk_scan.py    # Web风险扫描实现
│
├── gui/                    # 图形界面
│   ├── main.py             # GUI入口
│   ├── config_editor.py    # 配置编辑器
│   ├── plugin_config_editor.py  # 插件配置编辑器
│   ├── host_topology_networkx.py  # 主机拓扑图
│   ├── port_topology_networkx.py  # 端口拓扑图
│   ├── panels/             # 功能面板
│   │   ├── base_panel.py   # 面板基类
│   │   ├── host_scan_panel.py  # 主机扫描面板
│   │   ├── port_scan_panel.py  # 端口扫描面板
│   │   ├── dns_panel.py        # DNS检测面板
│   │   ├── traceroute_panel.py # 路由追踪面板
│   │   ├── ping_monitor_panel.py  # Ping监控面板
│   │   ├── tcp_ping_panel.py      # TCP Ping面板
│   │   ├── web_dir_scan_panel.py  # Web目录扫描面板
│   │   └── web_risk_scan_panel.py # Web风险扫描面板
│   └── __init__.py
│
├── logs/                   # 日志文件目录
│
├── plugins/                # 插件系统
│   ├── base_plugin.py      # 插件基类
│   ├── plugin_manager.py   # 插件管理器
│   ├── config_manager.py   # 插件配置管理
│   ├── web_risk/           # Web风险扫描插件
│   └── __init__.py
│
├── results/                # 扫描结果存储目录
│
├── tests/                  # 测试代码
│   ├── unit/               # 单元测试
│   ├── integration/        # 集成测试
│   └── __init__.py
│
├── utils/                  # 工具函数
│   ├── network.py          # 网络工具
│   ├── config.py           # 配置工具
│   └── export.py           # 数据导出工具
│
├── README.md               # 项目说明
├── requirements.txt        # 依赖清单
├── setup.py                # 安装脚本
├── host_params.json        # 测试参数
├── check_host_scanner.py   # 扫描器测试脚本
├── check_scanners.py       # 多扫描器测试脚本
└── networkx_test.py        # NetworkX测试脚本
```

### 3.2 核心目录说明

#### 3.2.1 `core/` 目录

包含所有扫描功能的核心实现，是项目的业务逻辑层：

- `base_scanner.py`: 定义了`BaseScanner`抽象基类和`ScanResult`数据类，所有扫描器的基础
- `scanner_manager.py`: 管理和调度各种扫描器的工厂类
- 各种扫描器实现文件：每个文件对应一种扫描功能，继承自`BaseScanner`

```python
# core/base_scanner.py 的核心内容
class BaseScanner(abc.ABC):
    """所有扫描器的基类"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.task_id = str(uuid.uuid4())
        self.running = False
        
    @abc.abstractmethod
    def validate_config(self) -> Tuple[bool, Optional[str]]:
        """验证配置参数"""
        pass
        
    @abc.abstractmethod
    def run_scan(self) -> ScanResult:
        """执行扫描"""
        pass
```

#### 3.2.2 `gui/` 目录

包含图形用户界面的实现：

- `main.py`: 应用程序主窗口，包含菜单、状态栏和Tab容器
- `panels/`: 每个扫描功能对应的UI面板，封装用户交互和结果展示
- `*_topology_networkx.py`: 网络拓扑图的可视化实现
- `config_editor.py`和`plugin_config_editor.py`: 配置编辑器

#### 3.2.3 `cli/` 目录

命令行界面的实现：

- `main.py`: 命令行程序入口，解析参数并调用相应功能
- 支持子命令如`run`、`list`、`config`等

#### 3.2.4 `plugins/` 目录

插件系统的核心实现：

- `base_plugin.py`: 定义插件接口
- `plugin_manager.py`: 插件的发现、加载和管理
- `config_manager.py`: 插件配置的读写
- 各种插件实现子目录，如`web_risk/`

#### 3.2.5 `utils/` 目录

通用工具和辅助函数：

- `network.py`: 网络操作相关工具函数
- `config.py`: 配置文件读写工具
- `export.py`: 支持CSV、JSON、Excel等格式的数据导出功能

#### 3.2.6 配置目录

- `config/`: 全局配置文件目录，包含`settings.ini`
- `configs/`: 插件和特定功能的配置文件目录，如`plugins/`下的各种JSON配置

#### 3.2.7 其他目录

- `logs/`: 日志输出目录
- `results/`: 扫描结果输出目录，CSV、JSON等格式的输出文件
- `tests/`: 单元测试和集成测试代码

### 3.3 文件命名规范

项目采用以下命名规范：

1. **Python文件**: 使用小写字母，单词之间用下划线分隔，如`base_scanner.py`
2. **类名**: 使用驼峰命名法，如`BaseScanner`、`HostScanPanel`
3. **函数和方法**: 使用小写字母，单词之间用下划线分隔，如`validate_config()`
4. **常量**: 使用大写字母，单词之间用下划线分隔，如`MAX_THREADS`
5. **配置文件**:
   - 插件配置使用小写字母，如`fingerprintscanner.json`
   - 主配置文件为`settings.ini`

### 3.4 模块依赖关系

项目的主要模块依赖关系如下：

```
cli/ ────────┐
             ├──> core/ <─── plugins/
gui/ ────────┘      │
                    ↓
                 utils/
```

- GUI和CLI层依赖于Core层，但Core层不依赖于UI层
- 插件系统扩展了Core层的功能
- Utils模块为其他模块提供通用功能
- 这种设计保证了业务逻辑与UI表现分离，便于测试和维护

## 4. 核心模块

### 4.1 基础扫描器

`core/base_scanner.py` 定义了所有扫描器的基类和扫描结果的数据结构，是整个系统的核心基础。

#### 4.1.1 ScanResult 数据类

```python
@dataclass
class ScanResult:
    """扫描结果数据类"""
    success: bool                  # 扫描是否成功
    data: List[Dict[str, Any]]     # 扫描结果数据列表
    error_msg: Optional[str] = None  # 错误信息
    start_time: float = 0.0        # 扫描开始时间
    end_time: float = 0.0          # 扫描结束时间
    metadata: Dict[str, Any] = None  # 元数据
    
    @property
    def duration(self) -> float:
        """返回扫描持续时间（秒）"""
        return self.end_time - self.start_time
    
    @property
    def record_count(self) -> int:
        """返回结果记录数量"""
        return len(self.data)
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式，用于序列化"""
        # 实现代码...
```

`ScanResult` 数据类封装了扫描结果的基本信息，包括：
- 成功标志
- 结果数据列表
- 错误信息
- 时间信息
- 元数据

它还提供了计算扫描时长和结果记录数的属性方法，以及转换为字典格式的方法，便于序列化和导出。

#### 4.1.2 BaseScanner 抽象基类

```python
class BaseScanner(abc.ABC):
    """
    扫描器基类
    所有网络工具模块都应继承此类并实现其抽象方法
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        """初始化扫描器"""
        self.module_name = self.__class__.__name__
        self.config = config or {}
        self.logger = logging.getLogger(f"scanner.{self.module_name}")
        self.task_id = str(uuid.uuid4())
        self.result = None
        self.running = False
        self.progress_callback = None
    
    def set_progress_callback(self, callback: Callable[[int, str], None]) -> None:
        """设置进度回调函数"""
        self.progress_callback = callback
    
    def update_progress(self, percent: int, message: str) -> None:
        """更新进度信息"""
        if self.progress_callback:
            self.progress_callback(percent, message)
        self.logger.debug(f"Progress: {percent}%, {message}")
    
    @abc.abstractmethod
    def validate_config(self) -> Tuple[bool, Optional[str]]:
        """验证配置参数是否有效"""
        pass
    
    @abc.abstractmethod
    def run_scan(self) -> ScanResult:
        """执行扫描操作"""
        pass
    
    def execute(self) -> ScanResult:
        """执行扫描并返回结果"""
        # 扫描前检查
        if self.running:
            self.logger.warning(f"Scanner {self.module_name} is already running")
            return ScanResult(success=False, data=[], 
                             error_msg=f"Scanner {self.module_name} is already running")
        
        # 设置状态和记录日志
        self.running = True
        self.logger.info(f"Starting {self.module_name} scan with task_id: {self.task_id}")
        self.update_progress(0, f"正在启动 {self.module_name} 扫描...")
        
        # 验证配置
        is_valid, error_msg = self.validate_config()
        if not is_valid:
            self.logger.error(f"Configuration validation failed: {error_msg}")
            self.running = False
            return ScanResult(success=False, data=[], error_msg=error_msg)
        
        # 执行扫描
        try:
            self.update_progress(5, "验证配置成功，开始扫描...")
            start_time = time.time()
            result = self.run_scan()
            end_time = time.time()
            
            # 更新时间信息
            result.start_time = start_time
            result.end_time = end_time
            
            # 记录结果
            self.result = result
            self.logger.info(f"Scan completed: {self.module_name}, records: {result.record_count}, "
                           f"duration: {result.duration:.2f}s")
            
            # 最终进度更新
            if result.success:
                self.update_progress(100, f"扫描完成，获取到 {result.record_count} 条记录")
            else:
                self.update_progress(100, f"扫描失败: {result.error_msg}")
            
            return result
        except Exception as e:
            # 异常处理
            self.logger.error(f"Scan failed: {str(e)}", exc_info=True)
            self.update_progress(100, f"扫描异常: {str(e)}")
            return ScanResult(success=False, data=[], error_msg=f"Scan error: {str(e)}",
                             start_time=time.time(), end_time=time.time())
        finally:
            # 清理状态
            self.running = False
    
    def stop(self) -> None:
        """停止扫描"""
        if self.running:
            self.logger.info(f"Stopping scan: {self.module_name}")
            self.update_progress(100, "扫描已停止")
            self.running = False
    
    @classmethod
    def get_scanner_info(cls) -> Dict[str, Any]:
        """获取扫描器基本信息"""
        return {
            "name": cls.__name__,
            "description": cls.__doc__.strip() if cls.__doc__ else "No description",
            "version": getattr(cls, "VERSION", "1.0.0")
        }
```

`BaseScanner` 类是所有扫描器的抽象基类，定义了扫描器的通用接口和功能：

- **初始化**：设置配置、日志记录器、任务ID等
- **进度回调**：通过 `set_progress_callback` 和 `update_progress` 实现进度通知
- **抽象方法**：
  - `validate_config`: 子类必须实现，验证配置参数
  - `run_scan`: 子类必须实现，执行实际的扫描逻辑
- **执行控制**：
  - `execute`: 封装了完整的扫描流程，包括前置检查、配置验证、扫描执行、结果处理和异常处理
  - `stop`: 提供停止扫描的机制
- **元信息**：通过 `get_scanner_info` 获取扫描器的基本信息

### 4.2 扫描器管理器

`core/scanner_manager.py` 实现了扫描器的注册、查找和创建功能：

```python
class ScannerManager:
    """扫描器管理器"""
    
    def __init__(self):
        self.scanners = {}
        self.logger = logging.getLogger("scanner.manager")
        self._load_scanners()
    
    def _load_scanners(self):
        """加载所有扫描器"""
        # 自动发现并注册core目录下的所有扫描器
        # ...
    
    def register_scanner(self, scanner_class):
        """注册扫描器类"""
        name = scanner_class.__name__
        self.scanners[name] = scanner_class
        self.logger.debug(f"Registered scanner: {name}")
    
    def get_scanner_class(self, name):
        """根据名称获取扫描器类"""
        return self.scanners.get(name)
    
    def create_scanner(self, name, config=None):
        """创建扫描器实例"""
        scanner_class = self.get_scanner_class(name)
        if scanner_class:
            return scanner_class(config)
        return None
    
    def get_available_scanners(self):
        """获取所有可用扫描器"""
        return {name: cls.get_scanner_info() for name, cls in self.scanners.items()}
```

扫描器管理器通过工厂模式实现扫描器的动态创建，主要功能包括：

- 自动发现和加载扫描器类
- 注册扫描器类
- 根据名称获取扫描器类或创建实例
- 提供可用扫描器列表

### 4.3 主要扫描模块

#### 4.3.1 主机扫描器 (`host_scan.py`)

主机扫描器用于发现局域网或指定IP范围内的活跃主机。

**主要功能**：
- 支持ARP、ICMP、TCP多种扫描方式
- 自动识别MAC地址和厂商信息
- 尝试识别操作系统类型
- 可选并发扫描提高效率

**实现要点**：
```python
class HostScanner(BaseScanner):
    """主机扫描器实现"""
    
    def validate_config(self):
        """验证IP范围、扫描方法等参数"""
        # ...
    
    def run_scan(self):
        """执行主机扫描"""
        # 选择扫描方法（ARP/ICMP/TCP）
        if self.config.get('method') == 'arp':
            return self._arp_scan()
        elif self.config.get('method') == 'icmp':
            return self._icmp_scan()
        elif self.config.get('method') == 'tcp':
            return self._tcp_scan()
        # ...
    
    def _arp_scan(self):
        """ARP扫描实现"""
        # 使用Scapy发送ARP请求
        # ...
    
    def _icmp_scan(self):
        """ICMP Ping扫描实现"""
        # 使用ICMP Echo请求
        # ...
    
    def _tcp_scan(self):
        """TCP SYN扫描实现"""
        # 尝试连接常用端口判断主机存活
        # ...
```

#### 4.3.2 端口扫描器 (`port_scan.py`)

端口扫描器用于检测目标主机开放的端口和服务。

**主要功能**：
- 支持TCP Connect、TCP SYN、UDP等扫描方式
- 服务版本识别
- 常见端口服务指纹匹配
- 可自定义端口范围和扫描速率

**实现要点**：
```python
class PortScanner(BaseScanner):
    """端口扫描器实现"""
    
    def validate_config(self):
        """验证目标主机和端口范围"""
        # ...
    
    def run_scan(self):
        """执行端口扫描"""
        # 根据配置选择扫描方法
        # ...
    
    def _tcp_connect_scan(self, target, ports):
        """TCP Connect扫描"""
        # 使用socket尝试连接
        # ...
    
    def _tcp_syn_scan(self, target, ports):
        """TCP SYN扫描（半开放扫描）"""
        # 使用Scapy发送SYN包
        # ...
    
    def _service_detection(self, target, port):
        """服务版本检测"""
        # 发送探测包并分析响应
        # ...
```

#### 4.3.3 DNS检测器 (`dns_check.py`)

DNS检测器用于域名解析和DNS记录查询。

**主要功能**：
- 查询各类DNS记录(A, AAAA, MX, NS, CNAME等)
- 子域名枚举
- DNS服务器检测
- DNS配置分析

**实现要点**：
```python
class DNSChecker(BaseScanner):
    """DNS检测实现"""
    
    def validate_config(self):
        """验证域名和查询类型"""
        # ...
    
    def run_scan(self):
        """执行DNS查询"""
        # 根据查询类型调用不同方法
        # ...
    
    def _query_record(self, domain, record_type):
        """查询特定类型的DNS记录"""
        # 使用dnspython查询
        # ...
    
    def _enumerate_subdomains(self, domain, wordlist):
        """子域名枚举"""
        # 遍历字典尝试解析子域名
        # ...
```

#### 4.3.4 路由追踪器 (`traceroute.py`)

路由追踪器用于分析数据包从源到目标经过的网络路径。

**主要功能**：
- 支持ICMP、UDP、TCP多种追踪方式
- 显示每一跳的IP和响应时间
- 尝试解析路由器主机名
- 提供地理位置信息（可选）

**实现要点**：
```python
class Tracerouter(BaseScanner):
    """路由追踪实现"""
    
    def validate_config(self):
        """验证目标和最大跳数"""
        # ...
    
    def run_scan(self):
        """执行路由追踪"""
        # 选择追踪方法
        # ...
    
    def _icmp_trace(self, target, max_hops):
        """使用ICMP进行追踪"""
        # 逐步增加TTL值发送ICMP包
        # ...
    
    def _tcp_trace(self, target, port, max_hops):
        """使用TCP进行追踪"""
        # 发送TCP SYN包并增加TTL
        # ...
```

#### 4.3.5 Ping监控器 (`ping_monitor.py`)

Ping监控器用于长期监控目标主机的可达性和网络质量。

**主要功能**：
- 连续Ping测试
- 统计响应时间和丢包率
- 设置告警阈值
- 生成统计报告和图表

**实现要点**：
```python
class PingMonitor(BaseScanner):
    """Ping监控实现"""
    
    def validate_config(self):
        """验证目标和监控参数"""
        # ...
    
    def run_scan(self):
        """执行Ping监控"""
        # 根据配置执行监控
        # ...
    
    def _ping_target(self, target, count):
        """对目标执行Ping测试"""
        # 使用ICMP Echo请求
        # ...
    
    def _analyze_results(self, results):
        """分析Ping结果"""
        # 计算平均/最小/最大响应时间和丢包率
        # ...
```

#### 4.3.6 Web目录扫描器 (`web_dir_scan.py`)

Web目录扫描器用于发现Web应用的目录和文件。

**主要功能**：
- 字典式目录和文件探测
- 支持自定义字典
- 识别返回状态和内容特征
- 支持多线程扫描

**实现要点**：
```python
class WebDirScanner(BaseScanner):
    """Web目录扫描实现"""
    
    def validate_config(self):
        """验证目标URL和扫描参数"""
        # ...
    
    def run_scan(self):
        """执行Web目录扫描"""
        # 加载字典并执行扫描
        # ...
    
    def _load_dictionary(self, dict_path):
        """加载扫描字典"""
        # 读取字典文件
        # ...
    
    def _scan_url(self, base_url, path):
        """扫描单个URL路径"""
        # 发送HTTP请求并分析响应
        # ...
```

#### 4.3.7 Web风险扫描器 (`web_risk_scan.py`)

Web风险扫描器用于检测Web应用的安全配置和常见漏洞。

**主要功能**：
- Web服务器指纹识别
- WAF(Web应用防火墙)检测
- HTTP安全响应头分析
- 常见漏洞探测（XSS、SQL注入等）

**实现要点**：
```python
class WebRiskScanner(BaseScanner):
    """Web风险扫描实现"""
    
    def validate_config(self):
        """验证目标URL和扫描选项"""
        # ...
    
    def run_scan(self):
        """执行Web风险扫描"""
        # 根据配置执行不同类型的安全检查
        # ...
    
    def _fingerprint_server(self, url):
        """识别Web服务器和技术栈"""
        # 分析HTTP响应头和页面内容
        # ...
    
    def _check_security_headers(self, url):
        """检查HTTP安全响应头配置"""
        # 检查各类安全相关HTTP头
        # ...
    
    def _detect_waf(self, url):
        """检测WAF存在"""
        # 发送特殊请求判断WAF特征
        # ...
    
    def _vulnerability_scan(self, url):
        """基本漏洞扫描"""
        # 尝试探测XSS、SQL注入等漏洞
        # ...
```

### 4.4 扫描模块通用设计原则

所有扫描模块遵循以下通用设计原则：

1. **继承基类**：继承`BaseScanner`并实现其抽象方法
2. **配置验证**：在`validate_config`中严格检查输入参数
3. **错误处理**：使用try-except捕获异常，提供明确的错误消息
4. **进度更新**：定期调用`update_progress`通知调用者当前进度
5. **可中断设计**：定期检查`self.running`标志，支持优雅停止
6. **模块化结构**：将复杂功能分解为多个私有方法
7. **详细日志**：使用logger记录关键操作和错误
8. **资源管理**：确保资源（如文件、网络连接）正确释放

## 5. 用户界面

### 5.1 命令行界面 (CLI)

命令行界面提供了一种快捷、可脚本化的方式使用各种扫描功能。CLI实现位于`cli/main.py`。

#### 5.1.1 命令结构

CLI采用子命令结构设计：

```
nettools-cli <command> [options]
```

主要命令包括：

- `list`: 列出所有可用的扫描模块
- `run`: 运行特定的扫描模块
- `config`: 管理全局配置
- `version`: 显示版本信息
- `help`: 显示帮助信息

#### 5.1.2 命令行参数处理

CLI使用`argparse`库处理命令行参数：

```python
def main():
    """命令行入口函数"""
    parser = argparse.ArgumentParser(
        description="NetTools - 网络扫描工具集",
        prog="nettools-cli"
    )
    
    # 创建子命令解析器
    subparsers = parser.add_subparsers(dest="command", help="可用命令")
    
    # list命令
    list_parser = subparsers.add_parser("list", help="列出可用模块")
    
    # run命令
    run_parser = subparsers.add_parser("run", help="运行扫描模块")
    run_parser.add_argument("module", help="要运行的模块名称")
    
    # 为每个模块添加特定参数
    _add_module_arguments(run_parser)
    
    # config命令
    config_parser = subparsers.add_parser("config", help="管理配置")
    config_parser.add_argument("action", choices=["show", "set", "reset"],
                              help="配置操作")
    
    # 解析参数并执行
    args = parser.parse_args()
    
    # 根据子命令分发处理
    if args.command == "list":
        _handle_list_command()
    elif args.command == "run":
        _handle_run_command(args)
    elif args.command == "config":
        _handle_config_command(args)
    else:
        parser.print_help()
```

#### 5.1.3 模块参数动态加载

CLI能够动态识别每个扫描模块支持的特定参数：

```python
def _add_module_arguments(parser):
    """为每个模块添加特定的命令行参数"""
    # 创建模块子解析器
    module_parsers = parser.add_subparsers(dest="module")
    
    # 为每个扫描模块添加特定参数
    # 主机扫描模块
    host_parser = module_parsers.add_parser("hostscanner", help="主机扫描")
    host_parser.add_argument("--ip_range", required=True, help="IP地址范围，如192.168.1.0/24")
    host_parser.add_argument("--method", choices=["arp", "icmp", "tcp"], default="icmp",
                           help="扫描方法")
    
    # 端口扫描模块
    port_parser = module_parsers.add_parser("portscanner", help="端口扫描")
    port_parser.add_argument("--target", required=True, help="目标主机IP或域名")
    port_parser.add_argument("--ports", default="1-1000", help="端口范围，如1-1000或common")
    
    # ... 其他模块的参数 ...
```

#### 5.1.4 执行流程

运行扫描模块的处理流程：

```python
def _handle_run_command(args):
    """处理run命令"""
    # 获取模块名和参数
    module_name = args.module
    
    # 从参数构建配置字典
    config = vars(args)
    
    # 创建扫描器实例
    scanner_manager = ScannerManager()
    scanner = scanner_manager.create_scanner(module_name, config)
    
    if not scanner:
        print(f"错误: 未找到模块 '{module_name}'")
        return
    
    # 设置进度回调
    scanner.set_progress_callback(_progress_callback)
    
    # 执行扫描
    print(f"正在执行 {module_name} 扫描...")
    result = scanner.execute()
    
    # 处理结果
    if result.success:
        print(f"扫描完成: 找到 {result.record_count} 条记录")
        _display_results(result)
    else:
        print(f"扫描失败: {result.error_msg}")
```

#### 5.1.5 结果输出与格式化

CLI支持多种格式的结果输出：

```python
def _display_results(result, format="table"):
    """显示扫描结果"""
    if format == "table":
        # 表格形式显示（使用prettytable或类似库）
        _display_as_table(result.data)
    elif format == "json":
        # JSON格式输出
        print(json.dumps(result.to_dict(), indent=2))
    
    # 如果指定了输出文件，保存结果
    if output_file:
        _save_results(result, output_file)
```

### 5.2 图形用户界面 (GUI)

图形用户界面使用PyQt5实现，提供直观的操作方式和可视化结果展示。

#### 5.2.1 主窗口

`gui/main.py` 实现应用程序主窗口：

```python
class MainWindow(QMainWindow):
    """主应用窗口"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("NetTools - 网络扫描工具箱")
        self.setMinimumSize(800, 600)
        
        # 初始化UI组件
        self.init_ui()
        
        # 加载配置
        self.config_manager = ConfigManager()
        
        # 创建状态栏
        self.statusBar().showMessage("就绪")
    
    def init_ui(self):
        """初始化UI组件"""
        # 创建菜单栏
        self.create_menu_bar()
        
        # 创建中央窗口部件和标签页
        self.central_widget = QTabWidget()
        self.setCentralWidget(self.central_widget)
        
        # 加载功能面板
        self.load_panels()
    
    def create_menu_bar(self):
        """创建菜单栏"""
        menubar = self.menuBar()
        
        # 文件菜单
        file_menu = menubar.addMenu("文件")
        
        # 配置菜单项
        config_action = QAction("配置", self)
        config_action.triggered.connect(self.open_config_editor)
        file_menu.addAction(config_action)
        
        # 退出菜单项
        exit_action = QAction("退出", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # 帮助菜单
        help_menu = menubar.addMenu("帮助")
        
        # 关于菜单项
        about_action = QAction("关于", self)
        about_action.triggered.connect(self.show_about_dialog)
        help_menu.addAction(about_action)
    
    def load_panels(self):
        """加载功能面板"""
        # 添加主机扫描面板
        self.host_scan_panel = HostScanPanel(self)
        self.central_widget.addTab(self.host_scan_panel, "主机扫描")
        
        # 添加端口扫描面板
        self.port_scan_panel = PortScanPanel(self)
        self.central_widget.addTab(self.port_scan_panel, "端口扫描")
        
        # ... 添加其他功能面板 ...
```

#### 5.2.2 面板基类

`gui/panels/base_panel.py` 定义了所有功能面板的基类：

```python
class BasePanel(QWidget):
    """功能面板基类"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.scanner = None
        self.scan_thread = None
        self.result = None
        
        # 初始化UI
        self.init_ui()
    
    def init_ui(self):
        """初始化UI组件"""
        # 主布局
        self.main_layout = QVBoxLayout()
        self.setLayout(self.main_layout)
        
        # 控制区域
        self.control_area = self.create_control_area()
        self.main_layout.addWidget(self.control_area)
        
        # 结果区域
        self.result_area = self.create_result_area()
        self.main_layout.addWidget(self.result_area)
        
        # 状态和进度区域
        self.status_area = self.create_status_area()
        self.main_layout.addWidget(self.status_area)
    
    def create_control_area(self):
        """创建控制区域（参数设置和操作按钮）"""
        # 子类应重写此方法
        control_group = QGroupBox("控制")
        layout = QVBoxLayout()
        control_group.setLayout(layout)
        return control_group
    
    def create_result_area(self):
        """创建结果显示区域"""
        # 子类应重写此方法
        result_group = QGroupBox("结果")
        layout = QVBoxLayout()
        
        # 默认使用表格显示
        self.result_table = QTableWidget()
        layout.addWidget(self.result_table)
        
        result_group.setLayout(layout)
        return result_group
    
    def create_status_area(self):
        """创建状态和进度区域"""
        status_group = QGroupBox("状态")
        layout = QHBoxLayout()
        
        # 状态信息
        self.status_label = QLabel("就绪")
        layout.addWidget(self.status_label)
        
        # 进度条
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)
        
        # 控制按钮
        self.start_button = QPushButton("开始扫描")
        self.start_button.clicked.connect(self.start_scan)
        layout.addWidget(self.start_button)
        
        self.stop_button = QPushButton("停止")
        self.stop_button.clicked.connect(self.stop_scan)
        self.stop_button.setEnabled(False)
        layout.addWidget(self.stop_button)
        
        status_group.setLayout(layout)
        return status_group
    
    def start_scan(self):
        """开始扫描操作"""
        # 获取配置参数（子类应实现获取参数的方法）
        config = self.get_config()
        
        # 创建扫描线程
        self.scan_thread = ScanThread(self.scanner_class, config)
        
        # 连接信号
        self.scan_thread.progress_update.connect(self.update_progress)
        self.scan_thread.scan_complete.connect(self.on_scan_complete)
        
        # 更新UI状态
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.status_label.setText("扫描中...")
        
        # 启动线程
        self.scan_thread.start()
    
    def stop_scan(self):
        """停止扫描操作"""
        if self.scan_thread and self.scan_thread.isRunning():
            self.status_label.setText("正在停止...")
            self.scan_thread.stop()
    
    def update_progress(self, percent, message):
        """更新进度信息"""
        self.progress_bar.setValue(percent)
        self.status_label.setText(message)
    
    def on_scan_complete(self, result):
        """扫描完成处理"""
        self.result = result
        
        # 更新UI状态
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        
        if result.success:
            self.status_label.setText(f"扫描完成: {result.record_count}条记录")
            self.display_results(result)
        else:
            self.status_label.setText(f"扫描失败: {result.error_msg}")
    
    def display_results(self, result):
        """显示扫描结果（子类应重写此方法）"""
        pass
    
    def get_config(self):
        """获取配置参数（子类应重写此方法）"""
        return {}
```

#### 5.2.3 扫描线程

为保持UI响应性，扫描操作通过独立的工作线程执行：

```python
class ScanThread(QThread):
    """扫描线程类"""
    
    # 自定义信号
    progress_update = pyqtSignal(int, str)  # 进度更新信号
    scan_complete = pyqtSignal(object)  # 扫描完成信号
    
    def __init__(self, scanner_class, config):
        super().__init__()
        self.scanner_class = scanner_class
        self.config = config
        self.scanner = None
    
    def run(self):
        """线程主函数"""
        # 创建扫描器实例
        self.scanner = self.scanner_class(self.config)
        
        # 设置进度回调函数
        self.scanner.set_progress_callback(self._progress_callback)
        
        # 执行扫描
        result = self.scanner.execute()
        
        # 发出扫描完成信号
        self.scan_complete.emit(result)
    
    def _progress_callback(self, percent, message):
        """进度回调函数"""
        self.progress_update.emit(percent, message)
    
    def stop(self):
        """停止扫描"""
        if self.scanner:
            self.scanner.stop()
```

#### 5.2.4 功能面板实现

每个扫描功能都有对应的GUI面板实现，下面以主机扫描面板为例：

```python
class HostScanPanel(BasePanel):
    """主机扫描面板"""
    
    def __init__(self, parent=None):
        # 设置扫描器类
        self.scanner_class = HostScanner
        super().__init__(parent)
    
    def create_control_area(self):
        """创建控制区域"""
        control_group = QGroupBox("扫描参数")
        form_layout = QFormLayout()
        
        # IP范围输入
        self.ip_range_input = QLineEdit()
        form_layout.addRow("IP范围:", self.ip_range_input)
        
        # 扫描方法选择
        self.method_combo = QComboBox()
        self.method_combo.addItems(["icmp", "arp", "tcp"])
        form_layout.addRow("扫描方法:", self.method_combo)
        
        # 高级选项
        self.advanced_options = QGroupBox("高级选项")
        self.advanced_options.setCheckable(True)
        self.advanced_options.setChecked(False)
        
        # 高级选项布局
        advanced_layout = QFormLayout()
        
        # 超时设置
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(1, 30)
        self.timeout_spin.setValue(2)
        advanced_layout.addRow("超时(秒):", self.timeout_spin)
        
        # 线程数设置
        self.threads_spin = QSpinBox()
        self.threads_spin.setRange(1, 100)
        self.threads_spin.setValue(10)
        advanced_layout.addRow("线程数:", self.threads_spin)
        
        self.advanced_options.setLayout(advanced_layout)
        form_layout.addRow(self.advanced_options)
        
        control_group.setLayout(form_layout)
        return control_group
    
    def create_result_area(self):
        """创建结果显示区域"""
        result_group = QGroupBox("扫描结果")
        layout = QVBoxLayout()
        
        # 选项卡
        result_tabs = QTabWidget()
        
        # 表格视图
        self.result_table = QTableWidget()
        self.result_table.setColumnCount(4)
        self.result_table.setHorizontalHeaderLabels(["IP地址", "MAC地址", "主机名", "状态"])
        result_tabs.addTab(self.result_table, "表格视图")
        
        # 拓扑视图
        self.topology_view = HostTopologyView()
        result_tabs.addTab(self.topology_view, "拓扑图")
        
        layout.addWidget(result_tabs)
        
        # 导出按钮
        export_layout = QHBoxLayout()
        
        self.export_csv_btn = QPushButton("导出CSV")
        self.export_csv_btn.clicked.connect(lambda: self.export_results("csv"))
        export_layout.addWidget(self.export_csv_btn)
        
        self.export_json_btn = QPushButton("导出JSON")
        self.export_json_btn.clicked.connect(lambda: self.export_results("json"))
        export_layout.addWidget(self.export_json_btn)
        
        layout.addLayout(export_layout)
        
        result_group.setLayout(layout)
        return result_group
    
    def get_config(self):
        """获取配置参数"""
        config = {
            "ip_range": self.ip_range_input.text(),
            "method": self.method_combo.currentText(),
            "timeout": self.timeout_spin.value(),
            "threads": self.threads_spin.value()
        }
        return config
    
    def display_results(self, result):
        """显示扫描结果"""
        # 清空表格
        self.result_table.setRowCount(0)
        
        # 添加数据行
        for i, host in enumerate(result.data):
            self.result_table.insertRow(i)
            self.result_table.setItem(i, 0, QTableWidgetItem(host.get("ip", "")))
            self.result_table.setItem(i, 1, QTableWidgetItem(host.get("mac", "")))
            self.result_table.setItem(i, 2, QTableWidgetItem(host.get("hostname", "")))
            self.result_table.setItem(i, 3, QTableWidgetItem(host.get("status", "")))
        
        # 更新拓扑图
        self.topology_view.update_topology(result.data)
    
    def export_results(self, format):
        """导出结果"""
        if not self.result or not self.result.data:
            QMessageBox.warning(self, "警告", "没有可导出的结果数据")
            return
        
        # 获取保存文件路径
        filename, _ = QFileDialog.getSaveFileName(
            self, "保存结果", "", 
            "CSV文件 (*.csv);;JSON文件 (*.json);;所有文件 (*.*)"
        )
        
        if not filename:
            return
        
        # 执行导出
        try:
            if format == "csv":
                ExportUtility.export_to_csv(self.result.data, filename)
            elif format == "json":
                ExportUtility.export_to_json(self.result.to_dict(), filename)
            
            QMessageBox.information(self, "导出成功", f"结果已成功导出到 {filename}")
        except Exception as e:
            QMessageBox.critical(self, "导出失败", f"导出过程中出错: {str(e)}")
```

#### 5.2.5 网络拓扑可视化

`gui/host_topology_networkx.py` 实现网络拓扑图的可视化：

```python
class HostTopologyView(QWidget):
    """主机拓扑图视图"""
    
    def __init__(self):
        super().__init__()
        self.graph = nx.Graph()
        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)
        
        # 工具栏
        self.toolbar = NavigationToolbar(self.canvas, self)
        
        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        self.setLayout(layout)
        
        # 布局算法选择
        self.layout_combo = QComboBox()
        self.layout_combo.addItems(["Spring", "Circular", "Shell", "Kamada-Kawai"])
        self.layout_combo.currentIndexChanged.connect(self.redraw_topology)
        
        layout.addWidget(QLabel("布局算法:"))
        layout.addWidget(self.layout_combo)
        
        # 初始化空拓扑图
        self.clear_topology()
    
    def update_topology(self, hosts_data):
        """更新拓扑图数据"""
        # 创建新图
        self.graph = nx.Graph()
        
        # 添加节点
        for host in hosts_data:
            ip = host.get("ip", "")
            if ip:
                self.graph.add_node(ip)
        
        # 尝试添加边（基于ARP表或者网络前缀等）
        # ...
        
        # 绘制图
        self.redraw_topology()
    
    def redraw_topology(self):
        """重绘拓扑图"""
        # 清空现有图
        self.figure.clear()
        
        # 没有数据时显示提示
        if not self.graph.nodes():
            ax = self.figure.add_subplot(111)
            ax.text(0.5, 0.5, "没有可显示的拓扑数据", ha="center", va="center")
            ax.axis("off")
            self.canvas.draw()
            return
        
        # 选择布局算法
        layout_name = self.layout_combo.currentText()
        if layout_name == "Spring":
            pos = nx.spring_layout(self.graph)
        elif layout_name == "Circular":
            pos = nx.circular_layout(self.graph)
        elif layout_name == "Shell":
            pos = nx.shell_layout(self.graph)
        elif layout_name == "Kamada-Kawai":
            pos = nx.kamada_kawai_layout(self.graph)
        
        # 绘制图
        ax = self.figure.add_subplot(111)
        nx.draw(self.graph, pos, with_labels=True, node_color="skyblue", 
               node_size=700, font_size=8, ax=ax)
        
        # 显示
        self.canvas.draw()
    
    def clear_topology(self):
        """清空拓扑图"""
        self.graph = nx.Graph()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        ax.text(0.5, 0.5, "没有拓扑数据", ha="center", va="center")
        ax.axis("off")
        self.canvas.draw()
```

### 5.3 配置编辑器

`gui/config_editor.py` 实现全局配置文件的编辑界面：

```python
class ConfigEditor(QDialog):
    """配置编辑器对话框"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("全局配置")
        self.setMinimumSize(500, 400)
        
        # 加载配置
        self.config_manager = ConfigManager()
        self.config = self.config_manager.load_config()
        
        self.init_ui()
    
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout()
        
        # 创建选项卡
        self.tab_widget = QTabWidget()
        
        # 通用设置选项卡
        self.general_tab = self.create_general_tab()
        self.tab_widget.addTab(self.general_tab, "通用设置")
        
        # 网络设置选项卡
        self.network_tab = self.create_network_tab()
        self.tab_widget.addTab(self.network_tab, "网络设置")
        
        # 日志设置选项卡
        self.logging_tab = self.create_logging_tab()
        self.tab_widget.addTab(self.logging_tab, "日志设置")
        
        layout.addWidget(self.tab_widget)
        
        # 按钮区域
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel | QDialogButtonBox.Apply | QDialogButtonBox.Reset
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        buttons.button(QDialogButtonBox.Apply).clicked.connect(self.apply_settings)
        buttons.button(QDialogButtonBox.Reset).clicked.connect(self.reset_settings)
        
        layout.addWidget(buttons)
        self.setLayout(layout)
    
    def create_general_tab(self):
        """创建通用设置选项卡"""
        # ...
    
    def create_network_tab(self):
        """创建网络设置选项卡"""
        # ...
    
    def create_logging_tab(self):
        """创建日志设置选项卡"""
        # ...
    
    def apply_settings(self):
        """应用设置"""
        # 从UI收集设置项
        # ...
        
        # 保存配置
        self.config_manager.save_config(self.config)
        QMessageBox.information(self, "保存成功", "配置已成功保存")
    
    def reset_settings(self):
        """重置为默认设置"""
        reply = QMessageBox.question(
            self, "确认重置", "确定要将所有设置重置为默认值吗？",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.config = self.config_manager.get_default_config()
            self.update_ui_from_config()
    
    def update_ui_from_config(self):
        """根据配置更新UI"""
        # ...
    
    def accept(self):
        """确定按钮处理"""
        self.apply_settings()
        super().accept()
```

## 6. 配置管理

配置管理系统负责读取、保存和验证应用程序的配置信息，确保各个模块能够获取正确的配置参数。

### 6.1 全局配置

全局配置文件采用INI格式，存储在`config/settings.ini`中。配置分为多个部分，包含应用程序的全局设置和各模块的默认配置。

#### 6.1.1 配置文件结构

一个典型的`settings.ini`文件结构如下：

```ini
[General]
log_level = INFO
result_dir = results
enable_plugins = true
default_timeout = 5
data_dir = data

[Network]
max_threads = 10
connection_timeout = 30
retry_attempts = 3
scan_delay = 0.5

[Scanner]
default_scan_method = icmp
port_batch_size = 100

[Logging]
log_to_file = true
log_file = logs/nettools.log
log_format = %%(asctime)s - %%(name)s - %%(levelname)s - %%(message)s
log_rotation = 7
```

#### 6.1.2 配置管理类

`utils/config.py` 中的 `ConfigManager` 类负责配置文件的读取和保存：

```python
class ConfigManager:
    """配置管理器"""
    
    def __init__(self, config_file="config/settings.ini"):
        self.config_file = config_file
        self.config = self._load_config()
    
    def _load_config(self):
        """加载配置文件"""
        config = configparser.ConfigParser()
        
        # 检查配置文件是否存在
        if not os.path.exists(self.config_file):
            # 创建默认配置
            self._create_default_config(config)
            # 确保目录存在
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            # 保存默认配置
            with open(self.config_file, 'w') as f:
                config.write(f)
        else:
            # 读取现有配置
            config.read(self.config_file)
        
        return config
    
    def _create_default_config(self, config):
        """创建默认配置"""
        # 通用设置
        config['General'] = {
            'log_level': 'INFO',
            'result_dir': 'results',
            'enable_plugins': 'true',
            'default_timeout': '5',
            'data_dir': 'data'
        }
        
        # 网络设置
        config['Network'] = {
            'max_threads': '10',
            'connection_timeout': '30',
            'retry_attempts': '3',
            'scan_delay': '0.5'
        }
        
        # 扫描器设置
        config['Scanner'] = {
            'default_scan_method': 'icmp',
            'port_batch_size': '100'
        }
        
        # 日志设置
        config['Logging'] = {
            'log_to_file': 'true',
            'log_file': 'logs/nettools.log',
            'log_format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            'log_rotation': '7'
        }
    
    def get_value(self, section, option, default=None):
        """获取配置项值"""
        try:
            return self.config.get(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError):
            return default
    
    def get_int(self, section, option, default=0):
        """获取整数配置项"""
        try:
            return self.config.getint(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError, ValueError):
            return default
    
    def get_float(self, section, option, default=0.0):
        """获取浮点数配置项"""
        try:
            return self.config.getfloat(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError, ValueError):
            return default
    
    def get_boolean(self, section, option, default=False):
        """获取布尔值配置项"""
        try:
            return self.config.getboolean(section, option)
        except (configparser.NoSectionError, configparser.NoOptionError, ValueError):
            return default
    
    def set_value(self, section, option, value):
        """设置配置项值"""
        # 确保section存在
        if not self.config.has_section(section):
            self.config.add_section(section)
        
        # 设置值
        self.config.set(section, option, str(value))
    
    def save_config(self):
        """保存配置到文件"""
        # 确保目录存在
        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
        
        # 保存配置
        with open(self.config_file, 'w') as f:
            self.config.write(f)
    
    def reset_to_default(self):
        """重置为默认配置"""
        # 创建一个新的配置解析器
        config = configparser.ConfigParser()
        
        # 设置默认值
        self._create_default_config(config)
        
        # 更新当前配置
        self.config = config
        
        # 保存到文件
        self.save_config()
```

#### 6.1.3 配置使用方式

在代码中使用全局配置的示例：

```python
# 获取配置管理器实例
config_manager = ConfigManager()

# 读取配置项
log_level = config_manager.get_value('Logging', 'log_level', 'INFO')
max_threads = config_manager.get_int('Network', 'max_threads', 10)
scan_delay = config_manager.get_float('Network', 'scan_delay', 0.5)
enable_plugins = config_manager.get_boolean('General', 'enable_plugins', True)

# 修改配置
config_manager.set_value('Network', 'max_threads', 20)
config_manager.save_config()
```

### 6.2 插件配置

插件配置使用JSON格式，存储在`configs/plugins/`目录下，每个插件对应一个配置文件。

#### 6.2.1 插件配置文件结构

插件配置文件示例 (`configs/plugins/fingerprintscanner.json`):

```json
{
    "name": "FingerprintScanner",
    "enabled": true,
    "version": "1.0.0",
    "description": "Web应用指纹识别插件",
    "settings": {
        "timeout": 10,
        "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36",
        "verify_ssl": true,
        "follow_redirects": true,
        "max_redirects": 5,
        "detection_mode": "aggressive"
    },
    "patterns": [
        {
            "name": "WordPress",
            "path": "/wp-login.php",
            "content": "WordPress",
            "headers": {
                "X-Powered-By": "WordPress"
            }
        },
        {
            "name": "Joomla",
            "path": "/administrator",
            "content": "Joomla"
        }
        // ... 更多模式 ...
    ]
}
```

#### 6.2.2 插件配置管理

`plugins/config_manager.py` 中的 `PluginConfigManager` 类负责插件配置的管理：

```python
class PluginConfigManager:
    """插件配置管理器"""
    
    def __init__(self, config_dir="configs/plugins"):
        self.config_dir = config_dir
        os.makedirs(config_dir, exist_ok=True)
    
    def get_plugin_config(self, plugin_name):
        """获取插件配置"""
        config_file = os.path.join(self.config_dir, f"{plugin_name.lower()}.json")
        
        # 检查配置文件是否存在
        if not os.path.exists(config_file):
            # 返回默认配置
            return self._get_default_config(plugin_name)
        
        # 读取配置文件
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            # 解析失败时返回默认配置
            return self._get_default_config(plugin_name)
    
    def save_plugin_config(self, plugin_name, config):
        """保存插件配置"""
        config_file = os.path.join(self.config_dir, f"{plugin_name.lower()}.json")
        
        # 确保目录存在
        os.makedirs(os.path.dirname(config_file), exist_ok=True)
        
        # 保存配置
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=4)
    
    def _get_default_config(self, plugin_name):
        """获取插件默认配置"""
        # 示例默认配置
        return {
            "name": plugin_name,
            "enabled": True,
            "version": "1.0.0",
            "description": f"{plugin_name} 插件",
            "settings": {}
        }
    
    def get_all_plugin_configs(self):
        """获取所有插件配置"""
        configs = {}
        
        # 遍历插件配置目录
        for filename in os.listdir(self.config_dir):
            if filename.endswith('.json'):
                plugin_name = os.path.splitext(filename)[0]
                configs[plugin_name] = self.get_plugin_config(plugin_name)
        
        return configs
    
    def reset_plugin_config(self, plugin_name):
        """重置插件配置为默认值"""
        default_config = self._get_default_config(plugin_name)
        self.save_plugin_config(plugin_name, default_config)
        return default_config
```

## 7. 插件系统

插件系统允许开发者扩展NetTools的功能，而无需修改核心代码。这种设计使得功能增强更加灵活，也便于第三方开发者贡献新功能。

### 7.1 插件基类

`plugins/base_plugin.py` 定义了插件接口，所有插件都应继承此类：

```python
class BasePlugin(abc.ABC):
    """插件基类
    
    所有NetTools插件都应该继承此类并实现其抽象方法。
    """
    
    def __init__(self, config=None):
        """初始化插件
        
        Args:
            config: 插件配置
        """
        self.config = config or {}
        self.name = self.__class__.__name__
        self.initialized = False
        self.logger = logging.getLogger(f"plugin.{self.name}")
    
    @abc.abstractmethod
    def initialize(self) -> bool:
        """初始化插件
        
        在此方法中进行插件的初始化操作，如加载资源、验证配置等。
        
        Returns:
            bool: 初始化是否成功
        """
        pass
    
    @abc.abstractmethod
    def execute(self, *args, **kwargs) -> Any:
        """执行插件功能
        
        插件的主要功能实现。
        
        Returns:
            Any: 执行结果
        """
        pass
    
    def cleanup(self) -> None:
        """清理资源
        
        在插件卸载或程序退出时调用，用于释放资源。
        """
        pass
    
    @classmethod
    def get_plugin_info(cls) -> Dict[str, Any]:
        """获取插件信息
        
        返回插件的基本信息，如名称、描述等。
        
        Returns:
            Dict: 插件信息字典
        """
        return {
            "name": cls.__name__,
            "description": cls.__doc__.strip() if cls.__doc__ else "No description",
            "version": getattr(cls, "VERSION", "1.0.0"),
            "author": getattr(cls, "AUTHOR", "Unknown"),
            "requires": getattr(cls, "REQUIRES", [])
        }
```

### 7.2 插件管理器

`plugins/plugin_manager.py` 实现了插件的发现、加载和管理：

```python
class PluginManager:
    """插件管理器
    
    负责插件的发现、加载和管理。
    """
    
    def __init__(self, plugins_dir="plugins", config_manager=None):
        """初始化插件管理器
        
        Args:
            plugins_dir: 插件目录
            config_manager: 配置管理器实例
        """
        self.plugins_dir = plugins_dir
        self.plugins = {}  # 已加载的插件: {name: instance}
        self.plugin_classes = {}  # 已注册的插件类: {name: class}
        self.logger = logging.getLogger("plugin.manager")
        
        # 插件配置管理器
        if config_manager:
            self.config_manager = config_manager
        else:
            from plugins.config_manager import PluginConfigManager
            self.config_manager = PluginConfigManager()
        
        # 全局配置管理器
        from utils.config import ConfigManager
        self.global_config = ConfigManager()
        
        # 检查是否启用插件
        self.enabled = self.global_config.get_boolean('General', 'enable_plugins', True)
        
        if self.enabled:
            # 加载插件
            self._discover_plugins()
    
    def _discover_plugins(self):
        """发现并注册插件"""
        # 检查插件目录是否存在
        if not os.path.isdir(self.plugins_dir):
            self.logger.warning(f"插件目录不存在: {self.plugins_dir}")
            return
        
        # 搜索插件模块
        for root, dirs, files in os.walk(self.plugins_dir):
            # 跳过特殊文件夹
            dirs[:] = [d for d in dirs if not d.startswith('_') and not d.startswith('.')]
            
            for file in files:
                # 只处理Python文件且不是特殊文件
                if file.endswith('.py') and not file.startswith('_'):
                    # 构造模块路径
                    rel_path = os.path.relpath(root, os.getcwd())
                    module_path = os.path.join(rel_path, file).replace(os.path.sep, '.')
                    module_name = os.path.splitext(module_path)[0]
                    
                    try:
                        # 导入模块
                        module = importlib.import_module(module_name)
                        
                        # 在模块中查找插件类
                        for attr_name in dir(module):
                            attr = getattr(module, attr_name)
                            
                            # 检查是否是BasePlugin的子类且不是BasePlugin本身
                            if (isinstance(attr, type) and 
                                issubclass(attr, BasePlugin) and 
                                attr is not BasePlugin):
                                # 注册插件类
                                self.register_plugin_class(attr)
                    except ImportError as e:
                        self.logger.error(f"加载插件模块失败: {module_name} - {str(e)}")
    
    def register_plugin_class(self, plugin_class):
        """注册插件类"""
        name = plugin_class.__name__
        self.plugin_classes[name] = plugin_class
        self.logger.debug(f"已注册插件类: {name}")
    
    def load_plugin(self, plugin_name):
        """加载插件实例"""
        # 检查插件是否已加载
        if plugin_name in self.plugins:
            return self.plugins[plugin_name]
        
        # 检查插件类是否已注册
        if plugin_name not in self.plugin_classes:
            self.logger.error(f"插件类未注册: {plugin_name}")
            return None
        
        # 获取插件配置
        plugin_config = self.config_manager.get_plugin_config(plugin_name)
        
        # 检查插件是否启用
        if not plugin_config.get("enabled", True):
            self.logger.info(f"插件已禁用: {plugin_name}")
            return None
        
        try:
            # 创建插件实例
            plugin_class = self.plugin_classes[plugin_name]
            plugin = plugin_class(plugin_config)
            
            # 初始化插件
            if plugin.initialize():
                self.plugins[plugin_name] = plugin
                self.logger.info(f"插件已加载: {plugin_name}")
                return plugin
            else:
                self.logger.error(f"插件初始化失败: {plugin_name}")
                return None
        except Exception as e:
            self.logger.error(f"加载插件异常: {plugin_name} - {str(e)}", exc_info=True)
            return None
    
    def get_plugin(self, plugin_name):
        """获取插件实例，如果尚未加载则加载插件"""
        # 检查插件是否启用
        if not self.enabled:
            return None
        
        # 尝试获取已加载的插件
        if plugin_name in self.plugins:
            return self.plugins[plugin_name]
        
        # 加载插件
        return self.load_plugin(plugin_name)
    
    def unload_plugin(self, plugin_name):
        """卸载插件"""
        if plugin_name in self.plugins:
            # 调用清理方法
            try:
                self.plugins[plugin_name].cleanup()
            except Exception as e:
                self.logger.error(f"插件清理异常: {plugin_name} - {str(e)}")
            
            # 移除插件
            del self.plugins[plugin_name]
            self.logger.info(f"插件已卸载: {plugin_name}")
            return True
        
        return False
    
    def get_all_plugin_classes(self):
        """获取所有已注册的插件类"""
        return {name: cls.get_plugin_info() for name, cls in self.plugin_classes.items()}
    
    def get_loaded_plugins(self):
        """获取所有已加载的插件"""
        return self.plugins.copy()
    
    def shutdown(self):
        """关闭插件管理器，卸载所有插件"""
        for plugin_name in list(self.plugins.keys()):
            self.unload_plugin(plugin_name)
        
        self.logger.info("所有插件已卸载")
```

### 7.3 实现插件

以Web指纹识别插件为例，说明如何实现一个具体的插件：

```python
class FingerprintScanner(BasePlugin):
    """Web应用指纹识别插件
    
    用于识别Web服务器、框架、CMS等技术栈。
    """
    
    VERSION = "1.0.0"
    AUTHOR = "NetTools Team"
    REQUIRES = ["requests>=2.25.0", "beautifulsoup4>=4.9.0"]
    
    def initialize(self) -> bool:
        """初始化插件"""
        # 检查配置
        if not self.config:
            self.logger.error("插件配置缺失")
            return False
        
        # 验证patterns是否存在
        if "patterns" not in self.config:
            self.logger.error("指纹模式配置缺失")
            return False
        
        # 设置默认值
        settings = self.config.get("settings", {})
        self.timeout = settings.get("timeout", 10)
        self.user_agent = settings.get("user_agent", "Mozilla/5.0 ...")
        self.verify_ssl = settings.get("verify_ssl", True)
        self.follow_redirects = settings.get("follow_redirects", True)
        
        # 加载指纹模式
        self.patterns = self.config.get("patterns", [])
        self.logger.info(f"已加载 {len(self.patterns)} 个指纹模式")
        
        # 初始化请求会话
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': self.user_agent
        })
        
        return True
    
    def execute(self, url: str, **kwargs) -> Dict[str, Any]:
        """执行指纹识别
        
        Args:
            url: 目标URL
            **kwargs: 可选参数
        
        Returns:
            Dict: 识别结果
        """
        # 验证URL
        if not url:
            return {
                "success": False,
                "error": "URL不能为空"
            }
        
        # 标准化URL
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
        
        # 提取域名
        domain = urlparse(url).netloc
        
        # 获取参数
        timeout = kwargs.get("timeout", self.timeout)
        verify_ssl = kwargs.get("verify_ssl", self.verify_ssl)
        
        # 初始化结果
        result = {
            "url": url,
            "domain": domain,
            "technologies": [],
            "headers": {},
            "success": True
        }
        
        try:
            # 请求根路径
            response = self.session.get(
                url, 
                timeout=timeout,
                verify=verify_ssl,
                allow_redirects=self.follow_redirects
            )
            
            # 保存响应头
            result["headers"] = dict(response.headers)
            
            # 提取服务器信息
            if 'Server' in response.headers:
                result["server"] = response.headers['Server']
            
            # 检查所有模式
            for pattern in self.patterns:
                if self._check_pattern(response, pattern, url):
                    result["technologies"].append(pattern["name"])
            
            return result
        
        except requests.RequestException as e:
            self.logger.error(f"请求异常: {url} - {str(e)}")
            return {
                "url": url,
                "domain": domain,
                "success": False,
                "error": str(e)
            }
    
    def _check_pattern(self, response, pattern, base_url):
        """检查指纹模式是否匹配"""
        # 检查特定路径
        if "path" in pattern:
            path_url = urljoin(base_url, pattern["path"])
            try:
                path_response = self.session.get(
                    path_url,
                    timeout=self.timeout,
                    verify=self.verify_ssl,
                    allow_redirects=self.follow_redirects
                )
                
                # 检查内容
                if "content" in pattern and pattern["content"] in path_response.text:
                    return True
                
                # 检查头部
                if "headers" in pattern:
                    for header_name, header_value in pattern["headers"].items():
                        if header_name in path_response.headers and \
                           header_value in path_response.headers[header_name]:
                            return True
            except:
                pass
        
        # 检查响应内容
        if "content" in pattern and pattern["content"] in response.text:
            return True
        
        # 检查响应头
        if "headers" in pattern:
            for header_name, header_value in pattern["headers"].items():
                if header_name in response.headers and \
                   header_value in response.headers[header_name]:
                    return True
        
        return False
    
    def cleanup(self) -> None:
        """清理资源"""
        if hasattr(self, 'session'):
            self.session.close()
```

### 7.4 使用插件

在其他模块中使用插件的示例：

```python
# 获取插件管理器实例
plugin_manager = PluginManager()

# 加载并使用指纹识别插件
fingerprint_plugin = plugin_manager.get_plugin("FingerprintScanner")
if fingerprint_plugin:
    result = fingerprint_plugin.execute("https://example.com")
    print(f"检测到的技术栈: {result['technologies']}")
else:
    print("指纹识别插件未加载")
```

### 7.5 插件开发指南

#### 7.5.1 创建新插件

1. 在 `plugins/` 目录下创建一个新的Python文件或子目录
2. 定义一个继承自 `BasePlugin` 的插件类
3. 实现 `initialize()` 和 `execute()` 方法
4. (可选) 在 `configs/plugins/` 目录下创建配置文件

#### 7.5.2 插件开发规范

1. **接口定义清晰**：`execute()` 方法的参数和返回值应有明确的定义
2. **错误处理**：妥善处理各种异常，避免插件错误影响主程序
3. **资源释放**：在 `cleanup()` 方法中释放所有资源
4. **信息提供**：通过类属性 (VERSION, AUTHOR, REQUIRES) 和文档字符串提供插件信息
5. **配置验证**：在 `initialize()` 中验证配置的有效性
6. **日志记录**：使用 `self.logger` 记录关键操作和错误

## 8. 工具与辅助模块

工具与辅助模块提供了一系列通用功能，供其他模块使用，避免代码重复并确保一致性。

### 8.1 网络工具 (utils/network.py)

网络工具模块封装了常用的网络操作，如IP地址处理、HTTP请求等。

```python
"""网络工具模块
提供网络操作相关的工具函数
"""

import socket
import ipaddress
import requests
import netifaces
from typing import List, Dict, Any, Optional, Tuple

def is_valid_ip(ip: str) -> bool:
    """
    验证IP地址格式是否有效
    
    Args:
        ip: 待验证的IP地址字符串
        
    Returns:
        bool: 是否为有效IP地址
    """
    try:
        ipaddress.ip_address(ip)
        return True
    except ValueError:
        return False

def is_valid_network(network: str) -> bool:
    """
    验证网络地址（CIDR格式）是否有效
    
    Args:
        network: 待验证的网络地址，如192.168.1.0/24
        
    Returns:
        bool: 是否为有效网络地址
    """
    try:
        ipaddress.ip_network(network)
        return True
    except ValueError:
        return False

def expand_ip_range(ip_range: str) -> List[str]:
    """
    展开IP范围为IP地址列表
    
    支持以下格式:
    - 单个IP: 192.168.1.1
    - CIDR格式: 192.168.1.0/24
    - 范围格式: 192.168.1.1-192.168.1.10
    - 通配符格式: 192.168.1.*
    
    Args:
        ip_range: IP范围字符串
        
    Returns:
        List[str]: IP地址列表
    """
    # 实现IP范围展开逻辑
    # ...

def get_mac_address(ip: str) -> Optional[str]:
    """
    获取指定IP地址的MAC地址
    
    Args:
        ip: 目标IP地址
        
    Returns:
        Optional[str]: MAC地址或None
    """
    # 实现MAC地址获取逻辑
    # ...

def get_hostname(ip: str) -> str:
    """
    尝试获取IP地址的主机名
    
    Args:
        ip: 目标IP地址
        
    Returns:
        str: 主机名或原始IP
    """
    try:
        return socket.gethostbyaddr(ip)[0]
    except (socket.herror, socket.gaierror):
        return ip

def get_local_interfaces() -> List[Dict[str, Any]]:
    """
    获取本地网络接口信息
    
    Returns:
        List[Dict]: 接口信息列表
    """
    interfaces = []
    
    for interface in netifaces.interfaces():
        addrs = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addrs:
            for addr in addrs[netifaces.AF_INET]:
                ip = addr.get('addr')
                if ip and ip != '127.0.0.1':
                    interfaces.append({
                        'name': interface,
                        'ip': ip,
                        'netmask': addr.get('netmask'),
                        'broadcast': addr.get('broadcast')
                    })
    
    return interfaces

def http_request(url: str, method: str = 'GET', **kwargs) -> Tuple[int, Dict, str]:
    """
    执行HTTP请求
    
    Args:
        url: 请求URL
        method: 请求方法
        **kwargs: 其他请求参数
        
    Returns:
        Tuple[int, Dict, str]: (状态码, 响应头, 响应内容)
    """
    try:
        response = requests.request(method, url, **kwargs)
        return response.status_code, dict(response.headers), response.text
    except requests.RequestException as e:
        return 0, {}, str(e)
```

### 8.2 导出工具 (utils/export.py)

导出工具模块用于将扫描结果导出为不同格式的文件。

```python
"""导出工具模块
提供将扫描结果导出为不同格式的功能
"""

import csv
import json
import os
from typing import List, Dict, Any, Optional
import pandas as pd

class ExportUtility:
    """导出工具类"""
    
    @staticmethod
    def export_to_csv(data: List[Dict[str, Any]], filename: str) -> bool:
        """
        导出数据到CSV文件
        
        Args:
            data: 数据列表，每项为一个字典
            filename: 输出文件名
            
        Returns:
            bool: 是否成功
        """
        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            
            # 获取所有字段
            if not data:
                return False
            
            fields = set()
            for item in data:
                fields.update(item.keys())
            
            # 写入CSV
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=list(fields))
                writer.writeheader()
                writer.writerows(data)
            
            return True
        except Exception as e:
            print(f"CSV导出失败: {str(e)}")
            return False
    
    @staticmethod
    def export_to_json(data: Any, filename: str) -> bool:
        """
        导出数据到JSON文件
        
        Args:
            data: 要导出的数据
            filename: 输出文件名
            
        Returns:
            bool: 是否成功
        """
        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            
            # 写入JSON
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            return True
        except Exception as e:
            print(f"JSON导出失败: {str(e)}")
            return False
    
    @staticmethod
    def export_to_excel(data: List[Dict[str, Any]], filename: str, sheet_name: str = 'Sheet1') -> bool:
        """
        导出数据到Excel文件
        
        Args:
            data: 数据列表，每项为一个字典
            filename: 输出文件名
            sheet_name: 工作表名称
            
        Returns:
            bool: 是否成功
        """
        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            
            # 转换为DataFrame
            df = pd.DataFrame(data)
            
            # 写入Excel
            with pd.ExcelWriter(filename) as writer:
                df.to_excel(writer, sheet_name=sheet_name, index=False)
            
            return True
        except Exception as e:
            print(f"Excel导出失败: {str(e)}")
            return False
    
    @staticmethod
    def format_scan_result_for_export(result: 'ScanResult') -> Dict[str, Any]:
        """
        格式化扫描结果用于导出
        
        Args:
            result: 扫描结果对象
            
        Returns:
            Dict: 格式化后的结果
        """
        # 转换为字典
        result_dict = result.to_dict()
        
        # 添加更多元信息
        result_dict['formatted_start_time'] = pd.to_datetime(result_dict['start_time']).strftime('%Y-%m-%d %H:%M:%S')
        result_dict['formatted_end_time'] = pd.to_datetime(result_dict['end_time']).strftime('%Y-%m-%d %H:%M:%S')
        result_dict['formatted_duration'] = f"{result_dict['duration']:.2f}秒"
        
        return result_dict
```

## 9. 数据可视化

NetTools提供了多种数据可视化方式，特别是网络拓扑图、统计图表和实时监控视图。主要使用NetworkX、Matplotlib和PyQt5的绘图能力。

### 9.1 网络拓扑图

网络拓扑图是NetTools的核心可视化功能之一，使用NetworkX库生成网络图，并通过Matplotlib或PyQt5显示。

#### 9.1.1 NetworkX集成

`gui/host_topology_networkx.py` 和 `gui/port_topology_networkx.py` 实现了网络拓扑图的生成和显示。

**主机拓扑图核心实现**:

```python
class HostTopologyView(QWidget):
    """主机拓扑图视图"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.graph = nx.Graph()
        
        # 创建Matplotlib画布
        self.figure = plt.figure(figsize=(8, 6))
        self.canvas = FigureCanvas(self.figure)
        
        # 创建导航工具栏
        self.toolbar = NavigationToolbar(self.canvas, self)
        
        # 创建控制面板
        self.controls = self._create_controls()
        
        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        layout.addWidget(self.controls)
        self.setLayout(layout)
        
        # 初始化图
        self.clear_graph()
    
    def _create_controls(self):
        """创建控制面板"""
        group_box = QGroupBox("拓扑图设置")
        layout = QHBoxLayout()
        
        # 布局算法选择
        layout.addWidget(QLabel("布局算法:"))
        self.layout_combo = QComboBox()
        self.layout_combo.addItems([
            "弹簧布局", "圆形布局", "同心圆布局", "Kamada-Kawai布局"
        ])
        self.layout_combo.currentIndexChanged.connect(self.redraw_graph)
        layout.addWidget(self.layout_combo)
        
        # 节点大小
        layout.addWidget(QLabel("节点大小:"))
        self.node_size_spin = QSpinBox()
        self.node_size_spin.setRange(100, 1000)
        self.node_size_spin.setValue(500)
        self.node_size_spin.setSingleStep(50)
        self.node_size_spin.valueChanged.connect(self.redraw_graph)
        layout.addWidget(self.node_size_spin)
        
        # 刷新按钮
        self.refresh_btn = QPushButton("刷新")
        self.refresh_btn.clicked.connect(self.redraw_graph)
        layout.addWidget(self.refresh_btn)
        
        group_box.setLayout(layout)
        return group_box
    
    def clear_graph(self):
        """清空图"""
        self.graph = nx.Graph()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        ax.text(0.5, 0.5, "无拓扑数据", ha='center', va='center')
        ax.axis('off')
        self.canvas.draw()
    
    def update_graph(self, hosts_data):
        """更新图数据"""
        # 创建新图
        self.graph = nx.Graph()
        
        # 网关和本机标识
        gateway_ip = None
        local_ip = None
        
        # 查找可能的网关
        for host in hosts_data:
            if host.get('is_gateway', False):
                gateway_ip = host['ip']
            if host.get('is_local', False):
                local_ip = host['ip']
        
        # 添加节点
        for host in hosts_data:
            ip = host['ip']
            self.graph.add_node(ip)
            
            # 设置节点属性
            node_attrs = {
                'label': host.get('hostname', ip),
                'type': 'gateway' if ip == gateway_ip else 'local' if ip == local_ip else 'host',
                'mac': host.get('mac', ''),
                'status': host.get('status', ''),
                'response_time': host.get('response_time', 0)
            }
            nx.set_node_attributes(self.graph, {ip: node_attrs})
        
        # 如果找到网关，以它为中心添加连接
        if gateway_ip:
            for node in self.graph.nodes():
                if node != gateway_ip:
                    self.graph.add_edge(gateway_ip, node)
        
        # 否则根据网络前缀推断连接
        else:
            nodes = list(self.graph.nodes())
            for i in range(len(nodes)):
                for j in range(i+1, len(nodes)):
                    # 简单判断：前3段相同则连接
                    ip1_parts = nodes[i].split('.')
                    ip2_parts = nodes[j].split('.')
                    if ip1_parts[:3] == ip2_parts[:3]:
                        self.graph.add_edge(nodes[i], nodes[j])
        
        # 绘制图
        self.redraw_graph()
    
    def redraw_graph(self):
        """重绘图"""
        # 清空图
        self.figure.clear()
        
        # 如果没有节点，显示提示文本
        if not self.graph.nodes():
            ax = self.figure.add_subplot(111)
            ax.text(0.5, 0.5, "无拓扑数据", ha='center', va='center')
            ax.axis('off')
            self.canvas.draw()
            return
        
        # 选择布局算法
        layout_idx = self.layout_combo.currentIndex()
        if layout_idx == 0:  # 弹簧布局
            pos = nx.spring_layout(self.graph)
        elif layout_idx == 1:  # 圆形布局
            pos = nx.circular_layout(self.graph)
        elif layout_idx == 2:  # 同心圆布局
            pos = nx.shell_layout(self.graph)
        elif layout_idx == 3:  # Kamada-Kawai布局
            pos = nx.kamada_kawai_layout(self.graph)
        
        # 获取节点大小
        node_size = self.node_size_spin.value()
        
        # 为不同类型的节点设置不同颜色
        node_colors = []
        for node in self.graph.nodes():
            node_type = self.graph.nodes[node].get('type', 'host')
            if node_type == 'gateway':
                node_colors.append('red')
            elif node_type == 'local':
                node_colors.append('green')
            else:
                node_colors.append('skyblue')
        
        # 绘制图
        ax = self.figure.add_subplot(111)
        nx.draw(
            self.graph, pos, 
            with_labels=True, 
            node_color=node_colors,
            node_size=node_size,
            font_size=10,
            ax=ax
        )
        
        # 更新画布
        self.canvas.draw()
```

#### 9.1.2 端口拓扑图

端口拓扑图用于可视化目标主机的端口状态和服务识别结果：

```python
class PortTopologyView(QWidget):
    """端口拓扑图视图"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # 实现类似于HostTopologyView，但针对端口数据
        # ...
```

### 9.2 统计图表

除了网络拓扑图，NetTools还提供了各种统计图表，用于展示如扫描结果分布、响应时间等数据。

#### 9.2.1 Ping监控图表

```python
class PingStatisticsChart(QWidget):
    """Ping统计图表"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 创建Matplotlib画布
        self.figure = plt.figure(figsize=(8, 4))
        self.canvas = FigureCanvas(self.figure)
        
        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.canvas)
        self.setLayout(layout)
        
        # 数据
        self.timestamps = []
        self.response_times = []
        self.packet_loss = []
        
        # 初始化图表
        self.init_chart()
    
    def init_chart(self):
        """初始化图表"""
        self.figure.clear()
        
        # 创建子图
        self.ax1 = self.figure.add_subplot(211)  # 响应时间图
        self.ax2 = self.figure.add_subplot(212)  # 丢包率图
        
        # 设置标题和标签
        self.ax1.set_title('Ping响应时间')
        self.ax1.set_ylabel('响应时间 (ms)')
        self.ax1.set_xlabel('时间')
        
        self.ax2.set_title('丢包率')
        self.ax2.set_ylabel('丢包率 (%)')
        self.ax2.set_xlabel('时间')
        self.ax2.set_ylim(0, 100)
        
        # 初始线条
        self.line1, = self.ax1.plot([], [], 'b-')
        self.line2, = self.ax2.plot([], [], 'r-')
        
        self.figure.tight_layout()
        self.canvas.draw()
    
    def update_chart(self, ping_data):
        """更新图表数据"""
        # 提取数据
        self.timestamps.append(ping_data['timestamp'])
        
        if ping_data['success']:
            self.response_times.append(ping_data['response_time'])
            self.packet_loss.append(0)
        else:
            self.response_times.append(None)
            self.packet_loss.append(100)
        
        # 保持最近100个数据点
        max_points = 100
        if len(self.timestamps) > max_points:
            self.timestamps = self.timestamps[-max_points:]
            self.response_times = self.response_times[-max_points:]
            self.packet_loss = self.packet_loss[-max_points:]
        
        # 更新图表
        self.redraw_chart()
class TestScannerIntegration(unittest.TestCase):
    def test_full_scan_workflow(self):
        pass
```

## 12. 常见问题与解决方案

## 13. 维护指南 